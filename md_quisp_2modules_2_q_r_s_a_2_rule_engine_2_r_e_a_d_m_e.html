<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuISP: MSM protocol details which take part in the RuleEngine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QuISP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_quisp_2modules_2_q_r_s_a_2_rule_engine_2_r_e_a_d_m_e.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">MSM protocol details which take part in the RuleEngine</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md44"></a></p>
<p>In a MSM protocol, the RuleEngine recieves an EPPSTimingNotification message. Then, the QNode prepares to emit photons from the specified timing with the specified interval. In this setting, the QNode contains an internal BSA, and the emitted photons are sent into there. The BSA performs a Bell state measurement on the emitted photon and one of the entangled photons sent from the EPPS.</p>
<p>After performing a single tiral of Bell state measurement, the result is sent back to the rule engine. Each emission iteration from the EPPS is counted locally at the QNode, named as <code>photon_index</code>. If we succeed in Bell state measurement we save the information of that qubit and <code>photon_index</code> in <code>success_list</code>, and for failure, we release that memory immediately. Then, we send a message to the partner QNode with the result of the BSM and the <code>photon_index</code>. When a QNode receives a result from its partner, it compares the qubits with the same <code>photon_index</code>, and the following operations are performed:</p>
<p>Local BSM: fail | Partner BSM: success/fail</p><ul>
<li>No action is taken.</li>
</ul>
<p>Local BSM: success | Partner BSM: fail</p><ul>
<li>Free the qubit that succeeded in the BSM.</li>
</ul>
<p>Local BSM: success | Partner BSM: success</p><ul>
<li>Based on the results, correct the qubits.</li>
<li>Save the information of the Bell pair in the bellpairstore.</li>
</ul>
<p>We will show a sequence diagram of the MSM protocol below.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant REA as RuleEngineA</div>
<div class="line">    participant BSAA as BellStateAnalyzerA</div>
<div class="line">    participant EPPS as EPPS</div>
<div class="line">    participant BSAB as BellStateAnalyzerB</div>
<div class="line">    participant REB as RuleEngineB</div>
<div class="line"> </div>
<div class="line">    EPPS-&gt;&gt;REA: EPPSTimingNotification</div>
<div class="line">    REA-&gt;&gt;REA: Call EMIT_PHOTONS_MSM(interval)</div>
<div class="line">    EPPS-&gt;&gt;REB: EPPSTimingNotification</div>
<div class="line">    REB-&gt;&gt;REB: Call EMIT_PHOTONS_MSM(interval)</div>
<div class="line">    loop Until the required number of qubits are created</div>
<div class="line">        par</div>
<div class="line">            EPPS-&gt;&gt;BSAA: PhotonicQubit</div>
<div class="line">            EPPS-&gt;&gt;BSAB: PhotonicQubit</div>
<div class="line">        end</div>
<div class="line">        REA-&gt;&gt;BSAA: PhotonicQubit</div>
<div class="line">        BSAA-&gt;&gt;BSAA: Perform Bell state measurement</div>
<div class="line">        BSAA-&gt;&gt;REA: SingleClickResult (Contains success, correction, qubit)</div>
<div class="line">        REB-&gt;&gt;BSAB: PhotonicQubit</div>
<div class="line">        BSAB-&gt;&gt;BSAB: Perform Bell state measurement</div>
<div class="line">        BSAB-&gt;&gt;REB: SingleClickResult (Contains success, correction, qubit)</div>
<div class="line">    end</div>
</div><!-- fragment --><p> After a RuleEngine recieves SingleClickResult, the following operations are performed between the QNodes, in a classical channel:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant REA as RuleEngine</div>
<div class="line">    participant PRT as PartnerRuleEngine</div>
<div class="line"> </div>
<div class="line">    REA-&gt;&gt;REA: Call handle_click_result(success, correction, qubit)</div>
<div class="line">    REA-&gt;&gt;PRT: MSMResult (Contains success, correction, photon_index)</div>
<div class="line">    PRT-&gt;&gt;PRT: Call handle_msm_result(success, correction, photon_index)</div>
</div><!-- fragment --><p>We will show a pseudocode for major functions related to the MSM protocol, which also appeard in the sequence diagram above.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Pseudocodes</h2>
<h3><a class="anchor" id="autotoc_md46"></a>
Global Variables</h3>
<ul>
<li><code>photon_index</code>: Variable to specify the entangled photon pair. We perform post-processing among memory qubits that share the same value of this variable.</li>
</ul>
<h1><a class="anchor" id="autotoc_md47"></a>
- <code>success_list</code>: List to store the information of memory qubits that succeeded local BSM. Contains the qubit information and the correction information.</h1>
<h3><a class="anchor" id="autotoc_md48"></a>
Function to emit photons from qnodes in msm links</h3>
<p><b>Input:</b></p><ul>
<li>Interval of emission specified by the EPPSTimingNotification: <code>interval</code></li>
</ul>
<p><b>function:</b> EMIT_PHOTONS_MSM(<code>interval</code>)</p><ol type="1">
<li>Increment <code>photon_index_counter</code></li>
</ol>
<ol type="1">
<li><b>If</b> There exist free memory qubits <b>then</b><ol type="a">
<li>Pick a free memory qubit and emit a photon from it </li>
</ol>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md49"></a>
1. Wait for <code>interval</code> time and call EMIT_PHOTONS_MSM(<code>interval</code>)</h1>
<h3><a class="anchor" id="autotoc_md50"></a>
Function to handle the click result</h3>
<p><b>Input:</b></p><ul>
<li>BSM success result: <code>success</code></li>
<li>BSM correction operation: <code>correction</code></li>
<li>Memory qubit which emitted photon for this BSM: <code>qubit</code></li>
</ul>
<p><b>function</b> HANDLE_CLICK_RESULT(<code>success</code>, <code>correction</code>, <code>qubit</code>)</p><ol type="1">
<li><b>If</b> <code>success</code> <b>then</b><ol type="a">
<li>Append <code>qubit</code> and <code>correction</code> to <code>success_list</code></li>
</ol>
</li>
</ol>
<ol type="1">
<li><b>Else</b><ol type="a">
<li>Free <code>qubit</code></li>
</ol>
</li>
</ol>
<ol type="1">
<li>Send <code>success, correction, photon_index</code> to the partner QNode</li>
</ol>
<hr  />
 <h3><a class="anchor" id="autotoc_md52"></a>
Function to handle the MSMResult</h3>
<p><b>Input:</b></p><ul>
<li>Partner BSM success result: <code>success</code></li>
<li>Partner BSM correction operation: <code>correction</code></li>
<li>Photon index the partner performed BSM with: <code>photon_index</code></li>
</ul>
<p><b>function</b> HANDLE_MSM_RESULT(<code>success</code>, <code>correction</code>, <code>photon_index</code>)</p><ol type="1">
<li><b>If</b> found <code>photon_index</code> in <code>success_list</code> <b>then</b><ol type="a">
<li>Set <code>correction_local</code> $\gets$ <code>success_list[photon_index].correction</code></li>
</ol>
<ol type="a">
<li>Set <code>qubit</code> $\gets$ <code>success_list[photon_index].qubit</code></li>
</ol>
<ol type="a">
<li><b>If</b> <code>success</code> <b>then</b><ol type="i">
<li><b>If</b> (<code>correction = correction_local</code> and <code>Addr_partner &lt; Addr_self</code>) <b>then</b><ol type="A">
<li>Apply Pauli Z Gate to <code>qubit</code> (The reason is explained in the section below)</li>
</ol>
<ol type="A">
<li>Save bell pair information</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol type="a">
<li><b>Else</b> </li>
</ol>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md53"></a>
1. Free <code>qubit</code></h1>
<h2><a class="anchor" id="autotoc_md54"></a>
Explanation of applying the Pauli Z gate for the case where the BSM results are different</h2>
<p>We prepare the following entangled state at the beginning of the protocol. $|\text{QNodeA}_\text{memory},\text{QNodeA}_\text{photon},\text{EPP}_\text{A},\text{EPP}_\text{B},\text{QNodeB}_\text{memory},\text{QNodeB}_\text{photon}\rangle=|\phi_+\rangle$</p>
<p>After emission, we perform a Bell state measurement at $|\text{QNodeA}_\text{photon}\text{EPP}_\text{A}\rangle$, and at $|\text{QNodeB}_\text{photon}\text{EPP}_\text{B}\rangle$.</p>
<p>Therefore, the quantum circuit for this operation can be described as follows.</p>
<div class="fragment"><div class="line">     ┌───┐          ┌───┐</div>
<div class="line">QAM: ┤ H ├──■────■──┤ H ├───────────────────</div>
<div class="line">     └───┘┌─┴─┐  │  └───┘┌─┐</div>
<div class="line">QAP: ─────┤ X ├──┼───────┤M├────────────────</div>
<div class="line">     ┌───┐└───┘┌─┴─┐ ┌─┐ └╥┘┌───┐</div>
<div class="line">EPA: ┤ H ├──■──┤ X ├─┤M├──╫─┤ X ├───────────</div>
<div class="line">     └───┘┌─┴─┐└───┘ └╥┘  ║ └─┬─┘     ┌─┐</div>
<div class="line">EPB: ─────┤ X ├───────╫───╫───┼───────┤M├────</div>
<div class="line">     ┌───┐└───┘       ║   ║   │  ┌───┐└╥┘┌─┐</div>
<div class="line">QBP: ┤ H ├──■─────────╫───╫───■──┤ H ├─╫─┤M├</div>
<div class="line">     └───┘┌─┴─┐       ║   ║      └───┘ ║ └╥┘</div>
<div class="line">QBM: ─────┤ X ├───────╫───╫────────────╫──╫─</div>
<div class="line">          └───┘       ║   ║            ║  ║</div>
<div class="line">reg: ═════════════════╩═══╩════════════╩══╩═</div>
<div class="line"> </div>
<div class="line">QAM: QNodeA_memory, QAP: QNodeA_photon, EPA: EPP_A, EPB: EPP_B, QBP: QNodeB_photon, QBM: QNodeB_memory</div>
</div><!-- fragment --><p> (In this senario we perform an optical BSM, so we cannot measure state $|\phi_{+}\rangle$ or $|\phi_{-}\rangle$ since they are indistinguishable. Those cases correpsond to when EPA and EPB measure state $|0\rangle$.)</p>
<p>With simple calculation, we can see that this quantum circuit will give us a quantum state as follows. $$ |\text{QNodeA}_\text{memory}\text{QNodeB}_\text{memory}\rangle = \frac{1}{\sqrt{2}}(|00\rangle + (-1)^{\psi^{A}+\psi^{B}}|11\rangle)$$ Here, $\psi^{A/B}$ is the result of the BSM at QNodeA/B, with values $\psi^{A/B} = 0$ for obtaining $|\psi_{+}\rangle$ and $\psi^{A/B} = 1$ for $|\psi_{-}\rangle$.</p>
<p>Therefore, we need to apply a Pauli Z gate to either memory qubit if $\psi^{A}$ is not the same value as $\psi^{B}$. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
