#include "EntangledPhotonPairSource.h"
#include "PhotonicQubit_m.h"
#include "omnetpp/ccontextswitcher.h"

using quisp::messages::PhotonicQubit;
using namespace omnetpp;

namespace quisp::modules {

Define_Module(EntangledPhotonPairSource);

StationaryQubit::StationaryQubit() : provider(utils::ComponentProvider{this}) {}

void EntangledPhotonPairSource::initialize() {
  emission_success_probability = par("error_rate").doubleValue();
  emission_x_error_rate = par("x_error_ratio").doubleValue();
  emission_y_error_rate = par("y_error_ratio").doubleValue();
  emission_z_error_rate = par("z_error_ratio").doubleValue();
  emission_jittering_standard_deviation = par("emission_jittering_standard_deviation").doubleValue();

  backend = provider.getQuantumBackend();
}

/**
 * \brief handle PhotonicQubit generated by StatinoryQubit itself
 *
 * \param msg is the PhotonicQubit message
 * Ask the why it is implemented like this
 */
void EntangledPhotonPairSource::handleMessage(cMessage *msg) {
  if (!msg->isSelfMessage()) {
    throw cRuntimeError("EntangledPhotonPairSource::handleMessage: message from outside is not expected");
  }
  double rand = dblrand();
  if (rand < (1 - emission_success_probability)) {
    PhotonicQubit *pk = check_and_cast<PhotonicQubit *>(msg);
    pk->setLost(true);
    send(pk, "to_quantum_port$o", 0);
    send(pk, "to_quantum_port$o", 1);
  } else {
    send(msg, "to_quantum_port$o", 0);
    send(msg, "to_quantum_port$o", 1);
  }
}

void EntangledPhotonPairSource::emitPhotons() {
  Enter_Method("emitPhotons()");
  auto *photon_one = new PhotonicQubit("Photon_one");
  auto *photon_two = new PhotonicQubit("Photon_two");
  auto *photon_one_ref = backend->getShortLiveQubit();
  auto *photon_two_ref = backend->getShortLiveQubit();
  photon_one_ref->noiselessH();
  photon_two_ref->noiselessCNOT(photon_one_ref);
  photon_one->setQubit_ref(photon_one_ref);
  photon_two->setQubit_ref(photon_two_ref);
  float jitter_timing = normal(0, emission_jittering_standard_deviation);
  float abso = fabs(jitter_timing);
  scheduleAt(simTime() + abso, photon_one);
  scheduleAt(simTime() + abso, photon_two);
}

}  // namespace quisp::modules
