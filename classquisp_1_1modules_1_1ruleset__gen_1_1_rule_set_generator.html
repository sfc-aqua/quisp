<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuISP: quisp::modules::ruleset_gen::RuleSetGenerator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QuISP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">quisp::modules::ruleset_gen::RuleSetGenerator Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_rule_set_generator_8h_source.html">RuleSetGenerator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43655ea451afc8a73cbda0ba39b63d33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#a43655ea451afc8a73cbda0ba39b63d33">RuleSetGenerator</a> (int <a class="el" href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#a0b7b5b88b8306f8a7ba394ca549c4bfc">responder_addr</a>)</td></tr>
<tr class="separator:a43655ea451afc8a73cbda0ba39b63d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9273ced5ba7f1f4881deba45b30d930"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, nlohmann::json &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#af9273ced5ba7f1f4881deba45b30d930">generateRuleSets</a> (messages::ConnectionSetupRequest *req, unsigned long ruleset_id)</td></tr>
<tr class="memdesc:af9273ced5ba7f1f4881deba45b30d930"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate RuleSets for the given connection setup request.  <a href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#af9273ced5ba7f1f4881deba45b30d930">More...</a><br /></td></tr>
<tr class="separator:af9273ced5ba7f1f4881deba45b30d930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a64febe1c242fa9aaf82f9fb73bedc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#a15a64febe1c242fa9aaf82f9fb73bedc">generateSimpleSwappingRuleSets</a> (std::map&lt; int, std::vector&lt; std::unique_ptr&lt; <a class="el" href="classquisp_1_1rules_1_1_rule.html">rules::Rule</a> &gt; &gt; &gt; &amp;rules_map, std::vector&lt; int &gt; &amp;path, std::vector&lt; int &gt; &amp;rev_path, std::map&lt; int, std::pair&lt; int, int &gt; &gt; &amp;swapping_partners_table, int num_measure)</td></tr>
<tr class="memdesc:a15a64febe1c242fa9aaf82f9fb73bedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate rules for each node in the path.  <a href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#a15a64febe1c242fa9aaf82f9fb73bedc">More...</a><br /></td></tr>
<tr class="separator:a15a64febe1c242fa9aaf82f9fb73bedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a961754c06d4bb59833546f21dbd0b402"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#a961754c06d4bb59833546f21dbd0b402">collectPath</a> (messages::ConnectionSetupRequest *req)</td></tr>
<tr class="memdesc:a961754c06d4bb59833546f21dbd0b402"><td class="mdescLeft">&#160;</td><td class="mdescRight">collect path infomation from initiator to responder  <a href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#a961754c06d4bb59833546f21dbd0b402">More...</a><br /></td></tr>
<tr class="separator:a961754c06d4bb59833546f21dbd0b402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d57e0d5a883d9b086e1721e9c8faf8"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#a68d57e0d5a883d9b086e1721e9c8faf8">collectSwappingPartners</a> (std::vector&lt; int &gt; &amp;path, int divisions, int hop_count)</td></tr>
<tr class="memdesc:a68d57e0d5a883d9b086e1721e9c8faf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">collect swapper and partners from the given path information  <a href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#a68d57e0d5a883d9b086e1721e9c8faf8">More...</a><br /></td></tr>
<tr class="separator:a68d57e0d5a883d9b086e1721e9c8faf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fddef8a10eec70cfce5147108ccaea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#aa9fddef8a10eec70cfce5147108ccaea">fillPathDivision</a> (std::vector&lt; int &gt; &amp;path, int i, int l, std::vector&lt; int &gt; &amp;link_left, std::vector&lt; int &gt; &amp;link_right, std::vector&lt; int &gt; &amp;swapper, int fill_start)</td></tr>
<tr class="separator:aa9fddef8a10eec70cfce5147108ccaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae460283f78bb799e05f4d39b4560ed8c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classquisp_1_1rules_1_1_rule.html">rules::Rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#ae460283f78bb799e05f4d39b4560ed8c">tomographyRule</a> (int partner_address, int owner_address, int num_measure, int shared_tag)</td></tr>
<tr class="memdesc:ae460283f78bb799e05f4d39b4560ed8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">create tomography rule  <a href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#ae460283f78bb799e05f4d39b4560ed8c">More...</a><br /></td></tr>
<tr class="separator:ae460283f78bb799e05f4d39b4560ed8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70aa9f1d520abf619d23155fd334a1c7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classquisp_1_1rules_1_1_rule.html">rules::Rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#a70aa9f1d520abf619d23155fd334a1c7">purifyRule</a> (int partner_address, <a class="el" href="namespacequisp_1_1rules.html#a5693ea435ef2194a383d996d838b066d">rules::PurType</a> purification_type, int shared_tag)</td></tr>
<tr class="memdesc:a70aa9f1d520abf619d23155fd334a1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">create purification rule  <a href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#a70aa9f1d520abf619d23155fd334a1c7">More...</a><br /></td></tr>
<tr class="separator:a70aa9f1d520abf619d23155fd334a1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c8ba075e2328e3a069303139774bb1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classquisp_1_1rules_1_1_rule.html">rules::Rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#a03c8ba075e2328e3a069303139774bb1">swapRule</a> (std::pair&lt; int, int &gt; partner_address, int shared_tag)</td></tr>
<tr class="memdesc:a03c8ba075e2328e3a069303139774bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">create entanglement swapping rule  <a href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#a03c8ba075e2328e3a069303139774bb1">More...</a><br /></td></tr>
<tr class="separator:a03c8ba075e2328e3a069303139774bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0b7b5b88b8306f8a7ba394ca549c4bfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html#a0b7b5b88b8306f8a7ba394ca549c4bfc">responder_addr</a></td></tr>
<tr class="separator:a0b7b5b88b8306f8a7ba394ca549c4bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a43655ea451afc8a73cbda0ba39b63d33" name="a43655ea451afc8a73cbda0ba39b63d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43655ea451afc8a73cbda0ba39b63d33">&#9670;&#160;</a></span>RuleSetGenerator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">quisp::modules::ruleset_gen::RuleSetGenerator::RuleSetGenerator </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>responder_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a961754c06d4bb59833546f21dbd0b402" name="a961754c06d4bb59833546f21dbd0b402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961754c06d4bb59833546f21dbd0b402">&#9670;&#160;</a></span>collectPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; quisp::modules::ruleset_gen::RuleSetGenerator::collectPath </td>
          <td>(</td>
          <td class="paramtype">messages::ConnectionSetupRequest *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>collect path infomation from initiator to responder </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;int&gt; vector to store node addresses </dd></dl>

</div>
</div>
<a id="a68d57e0d5a883d9b086e1721e9c8faf8" name="a68d57e0d5a883d9b086e1721e9c8faf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d57e0d5a883d9b086e1721e9c8faf8">&#9670;&#160;</a></span>collectSwappingPartners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, std::pair&lt; int, int &gt; &gt; quisp::modules::ruleset_gen::RuleSetGenerator::collectSwappingPartners </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>divisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hop_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>collect swapper and partners from the given path information </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td></td></tr>
    <tr><td class="paramname">divisions</td><td></td></tr>
    <tr><td class="paramname">hop_count</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;int, std::pair&lt;int, int&gt;&gt; swapper addr -&gt; {left partner addr, right partner addr} </dd></dl>
<p >recognize partner. (which node is left partner, right partner) Currently, we choose every other node in the path to do swapping in the first round. In the examples below, the number in parentheses is the round of swapping, and designates which nodes are swapping. If the number of hops is a power of two, we get something like </p><pre class="fragment">/// node1 --- node2(1) --- node3 --- node4(1) --- node5
/// node1 ---------------- node3 ---------------- node5
/// node1 ---------------- node3(2) ------------- node5
/// node1 --------------------------------------- node5
/// </pre><p> If the number of hops is not a power of two, at some stage the number of hops will become become odd as we proceed, forcing us to decide which to do first. In this version of the code, we just give priority starting from the left (start of our list) </p><pre class="fragment">/// node1 --- node2(1) --- node3 --- node4(1) --- node5 --- node6
/// node1 ---------------- node3 ---------------- node5 --- node6
/// node1 ---------------- node3(2) ------------- node5 --- node6
/// node1 --------------------------------------- node5 --- node6
/// node1 ------------------------------------ node5(3) --- node6
/// node1 ------------------------------------------------- node6
/// </pre><p> todo hypothetically, with no purification, all of the intermediate nodes could swap asynchronously and essentially simultaneously. In fact, that's probably what we want, to minimize decoherence. But, the condition clause will have to be extended in order to support "when part of this connection" rather than "when entangled with this node" and you have to be careful of not creating the wrong result by accident.</p>

</div>
</div>
<a id="aa9fddef8a10eec70cfce5147108ccaea" name="aa9fddef8a10eec70cfce5147108ccaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fddef8a10eec70cfce5147108ccaea">&#9670;&#160;</a></span>fillPathDivision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int quisp::modules::ruleset_gen::RuleSetGenerator::fillPathDivision </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>link_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>link_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>swapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Treat subpath [i:...] of length l </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Nodes on the connection setup path </td></tr>
    <tr><td class="paramname">i</td><td>Left of the subpath to consider </td></tr>
    <tr><td class="paramname">l</td><td>Length of the subpath </td></tr>
    <tr><td class="paramname">link_left</td><td>Left part of the list of "links" </td></tr>
    <tr><td class="paramname">link_right</td><td>Right part </td></tr>
    <tr><td class="paramname">swapper</td><td>Swappers to create those links (might be -1 for real links) </td></tr>
    <tr><td class="paramname">fill_start</td><td>[0:fill_start[ is already filled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9273ced5ba7f1f4881deba45b30d930" name="af9273ced5ba7f1f4881deba45b30d930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9273ced5ba7f1f4881deba45b30d930">&#9670;&#160;</a></span>generateRuleSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, <a class="el" href="namespacequisp_1_1modules.html#ac5600e2cedff8162864c3e7019ccd4d3">json</a> &gt; quisp::modules::ruleset_gen::RuleSetGenerator::generateRuleSets </td>
          <td>(</td>
          <td class="paramtype">messages::ConnectionSetupRequest *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ruleset_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generate RuleSets for the given connection setup request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td></td></tr>
    <tr><td class="paramname">ruleset_id</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;int, nlohmann::json&gt; a map of json serialized RuleSets and its node addresses as key </dd></dl>

</div>
</div>
<a id="a15a64febe1c242fa9aaf82f9fb73bedc" name="a15a64febe1c242fa9aaf82f9fb73bedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a64febe1c242fa9aaf82f9fb73bedc">&#9670;&#160;</a></span>generateSimpleSwappingRuleSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quisp::modules::ruleset_gen::RuleSetGenerator::generateSimpleSwappingRuleSets </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; int, std::vector&lt; std::unique_ptr&lt; <a class="el" href="classquisp_1_1rules_1_1_rule.html">rules::Rule</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rules_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rev_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>swapping_partners_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_measure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generate rules for each node in the path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rules_map</td><td></td></tr>
    <tr><td class="paramname">path</td><td></td></tr>
    <tr><td class="paramname">rev_path</td><td></td></tr>
    <tr><td class="paramname">swapping_partners_table</td><td></td></tr>
    <tr><td class="paramname">num_measure</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70aa9f1d520abf619d23155fd334a1c7" name="a70aa9f1d520abf619d23155fd334a1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70aa9f1d520abf619d23155fd334a1c7">&#9670;&#160;</a></span>purifyRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classquisp_1_1rules_1_1_rule.html">Rule</a> &gt; quisp::modules::ruleset_gen::RuleSetGenerator::purifyRule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partner_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacequisp_1_1rules.html#a5693ea435ef2194a383d996d838b066d">rules::PurType</a>&#160;</td>
          <td class="paramname"><em>purification_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shared_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create purification rule </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partner_address</td><td></td></tr>
    <tr><td class="paramname">purification_type</td><td></td></tr>
    <tr><td class="paramname">shared_tag</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;rules::Rule&gt; </dd></dl>

</div>
</div>
<a id="a03c8ba075e2328e3a069303139774bb1" name="a03c8ba075e2328e3a069303139774bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c8ba075e2328e3a069303139774bb1">&#9670;&#160;</a></span>swapRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classquisp_1_1rules_1_1_rule.html">Rule</a> &gt; quisp::modules::ruleset_gen::RuleSetGenerator::swapRule </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>partner_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shared_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create entanglement swapping rule </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partner_address</td><td></td></tr>
    <tr><td class="paramname">shared_tag</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;rules::Rule&gt; </dd></dl>

</div>
</div>
<a id="ae460283f78bb799e05f4d39b4560ed8c" name="ae460283f78bb799e05f4d39b4560ed8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae460283f78bb799e05f4d39b4560ed8c">&#9670;&#160;</a></span>tomographyRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classquisp_1_1rules_1_1_rule.html">Rule</a> &gt; quisp::modules::ruleset_gen::RuleSetGenerator::tomographyRule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partner_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>owner_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_measure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shared_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create tomography rule </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partner_address</td><td></td></tr>
    <tr><td class="paramname">owner_address</td><td></td></tr>
    <tr><td class="paramname">num_measure</td><td></td></tr>
    <tr><td class="paramname">shared_tag</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;rules::Rule&gt; </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0b7b5b88b8306f8a7ba394ca549c4bfc" name="a0b7b5b88b8306f8a7ba394ca549c4bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7b5b88b8306f8a7ba394ca549c4bfc">&#9670;&#160;</a></span>responder_addr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int quisp::modules::ruleset_gen::RuleSetGenerator::responder_addr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>quisp/modules/QRSA/ConnectionManager/<a class="el" href="_rule_set_generator_8h_source.html">RuleSetGenerator.h</a></li>
<li>quisp/modules/QRSA/ConnectionManager/<a class="el" href="_rule_set_generator_8cc.html">RuleSetGenerator.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacequisp.html">quisp</a></li><li class="navelem"><a class="el" href="namespacequisp_1_1modules.html">modules</a></li><li class="navelem"><a class="el" href="namespacequisp_1_1modules_1_1ruleset__gen.html">ruleset_gen</a></li><li class="navelem"><a class="el" href="classquisp_1_1modules_1_1ruleset__gen_1_1_rule_set_generator.html">RuleSetGenerator</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
