//
// Generated file, do not edit! Created by opp_msgtool 6.0 from inet/transportlayer/rtp/RtpInnerPacket.msg.
//

#ifndef __INET__RTP_RTPINNERPACKET_M_H
#define __INET__RTP_RTPINNERPACKET_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {
namespace rtp {

class RtpInnerPacket;

}  // namespace rtp
}  // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/networklayer/contract/ipv4/Ipv4Address_m.h" // import inet.networklayer.contract.ipv4.Ipv4Address

#include "inet/transportlayer/rtp/RtpSenderControlMessage_m.h" // import inet.transportlayer.rtp.RtpSenderControlMessage

#include "inet/transportlayer/rtp/RtpSenderStatusMessage_m.h" // import inet.transportlayer.rtp.RtpSenderStatusMessage

// cplusplus {{
#include "inet/common/packet/Packet.h"
#include "inet/transportlayer/rtp/RtpPacket_m.h"
// }}


namespace inet {
namespace rtp {

/**
 * Enum generated from <tt>inet/transportlayer/rtp/RtpInnerPacket.msg:25</tt> by opp_msgtool.
 * <pre>
 * //
 * // This enumeration is a list of all possibly types of
 * // an ~RtpInnerPacket.
 * //
 * enum RtpInpType
 * {
 *     RTP_INP_UNDEF = 0;
 *     RTP_INP_INITIALIZE_PROFILE = 1;
 *     RTP_INP_PROFILE_INITIALIZED = 2;
 *     RTP_INP_INITIALIZE_RTCP = 3;
 *     RTP_INP_RTCP_INITIALIZED = 4;
 *     RTP_INP_CREATE_SENDER_MODULE = 5;
 *     RTP_INP_SENDER_MODULE_CREATED = 6;
 *     RTP_INP_DELETE_SENDER_MODULE = 7;
 *     RTP_INP_SENDER_MODULE_DELETED = 8;
 *     RTP_INP_INITIALIZE_SENDER_MODULE = 9;
 *     RTP_INP_SENDER_MODULE_INITIALIZED = 10;
 *     RTP_INP_SENDER_MODULE_CONTROL = 11;
 *     RTP_INP_SENDER_MODULE_STATUS = 12;
 *     RTP_INP_LEAVE_SESSION = 13;
 *     RTP_INP_SESSION_LEFT = 14;
 *     RTP_INP_DATA_OUT = 15;
 *     RTP_INP_DATA_IN = 16;
 * }
 * </pre>
 */
enum RtpInpType {
    RTP_INP_UNDEF = 0,
    RTP_INP_INITIALIZE_PROFILE = 1,
    RTP_INP_PROFILE_INITIALIZED = 2,
    RTP_INP_INITIALIZE_RTCP = 3,
    RTP_INP_RTCP_INITIALIZED = 4,
    RTP_INP_CREATE_SENDER_MODULE = 5,
    RTP_INP_SENDER_MODULE_CREATED = 6,
    RTP_INP_DELETE_SENDER_MODULE = 7,
    RTP_INP_SENDER_MODULE_DELETED = 8,
    RTP_INP_INITIALIZE_SENDER_MODULE = 9,
    RTP_INP_SENDER_MODULE_INITIALIZED = 10,
    RTP_INP_SENDER_MODULE_CONTROL = 11,
    RTP_INP_SENDER_MODULE_STATUS = 12,
    RTP_INP_LEAVE_SESSION = 13,
    RTP_INP_SESSION_LEFT = 14,
    RTP_INP_DATA_OUT = 15,
    RTP_INP_DATA_IN = 16
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RtpInpType& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RtpInpType& e) { int n; b->unpack(n); e = static_cast<RtpInpType>(n); }

/**
 * Class generated from <tt>inet/transportlayer/rtp/RtpInnerPacket.msg:49</tt> by opp_msgtool.
 * <pre>
 * //
 * // This class is used for communication between submodules of the RTP layer module.
 * //
 * packet RtpInnerPacket
 * {
 *     // The type of this ~RtpInnerPacket.
 *     RtpInpType type = RTP_INP_UNDEF;
 * 
 *     // The CNAME
 *     string commonName;
 * 
 *     // The MTU
 *     int mtu;
 * 
 *     // The Bandwidth
 *     int bandwidth;
 * 
 *     // The RTCP percentage
 *     int rtcpPercentage;
 * 
 *     // The Ipv4 address
 *     Ipv4Address address = Ipv4Address::UNSPECIFIED_ADDRESS;
 * 
 *     // The port number
 *     int port = PORT_UNDEF;
 * 
 *     // The SSRC identifier
 *     uint32_t ssrc;
 * 
 *     // The payload type
 *     int payloadType;
 * 
 *     // The file name
 *     string fileName;
 * 
 *     // The clock rate
 *     int clockRate;
 * 
 *     // The RTP time stamp base
 *     int timeStampBase;
 * 
 *     // The RTP sequence number base
 *     int sequenceNumberBase;
 * }
 * </pre>
 */
class INET_API RtpInnerPacket : public ::omnetpp::cPacket
{
  protected:
    RtpInpType type = RTP_INP_UNDEF;
    ::omnetpp::opp_string commonName;
    int mtu = 0;
    int bandwidth = 0;
    int rtcpPercentage = 0;
    ::inet::Ipv4Address address = Ipv4Address::UNSPECIFIED_ADDRESS;
    int port = PORT_UNDEF;
    uint32_t ssrc = 0;
    int payloadType = 0;
    ::omnetpp::opp_string fileName;
    int clockRate = 0;
    int timeStampBase = 0;
    int sequenceNumberBase = 0;

  private:
    void copy(const RtpInnerPacket& other);

  protected:
    bool operator==(const RtpInnerPacket&) = delete;

  public:
    RtpInnerPacket(const char *name=nullptr, short kind=0);
    RtpInnerPacket(const RtpInnerPacket& other);
    virtual ~RtpInnerPacket();
    RtpInnerPacket& operator=(const RtpInnerPacket& other);
    virtual RtpInnerPacket *dup() const override {return new RtpInnerPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual RtpInpType getType() const;
    virtual void setType(RtpInpType type);

    virtual const char * getCommonName() const;
    virtual void setCommonName(const char * commonName);

    virtual int getMtu() const;
    virtual void setMtu(int mtu);

    virtual int getBandwidth() const;
    virtual void setBandwidth(int bandwidth);

    virtual int getRtcpPercentage() const;
    virtual void setRtcpPercentage(int rtcpPercentage);

    virtual const ::inet::Ipv4Address& getAddress() const;
    virtual ::inet::Ipv4Address& getAddressForUpdate() { return const_cast<::inet::Ipv4Address&>(const_cast<RtpInnerPacket*>(this)->getAddress());}
    virtual void setAddress(const ::inet::Ipv4Address& address);

    virtual int getPort() const;
    virtual void setPort(int port);

    virtual uint32_t getSsrc() const;
    virtual void setSsrc(uint32_t ssrc);

    virtual int getPayloadType() const;
    virtual void setPayloadType(int payloadType);

    virtual const char * getFileName() const;
    virtual void setFileName(const char * fileName);

    virtual int getClockRate() const;
    virtual void setClockRate(int clockRate);

    virtual int getTimeStampBase() const;
    virtual void setTimeStampBase(int timeStampBase);

    virtual int getSequenceNumberBase() const;
    virtual void setSequenceNumberBase(int sequenceNumberBase);


  public:
    /**
     * Writes a short info about this RtpInnerPacket into the given string.
     */
    virtual std::string str() const override;

    /**
     * Writes a longer info about this RtpInnerPacket into the given output stream.
     */
    virtual void dump(std::ostream& os) const;

    /**
     * Called by the rtp module after creating the profile module. It
     * informes the profile about the maximum size an rtp packet can have.
     */
    virtual void setInitializeProfilePkt(int mtu);

    /**
     * Called by the profile module after it has received the initializeProfile()
     * message. It informs the rtp module about the percentage of the available
     * bandwidth to be used by rtcp and the preferred port for this profile.
     */
    virtual void setProfileInitializedPkt(int rtcpPercentage, int port);

    /**
     * Called by the rtp module to inform the rtcp module about mandatory
     * information for starting the rtp session.
     */
    virtual void setInitializeRTCPPkt(const char *commonName, int mtu, int bandwidth,
            int rtcpPercentage, Ipv4Address address, int port);

    /**
     * Called by the rtcp module after it has waited for half an rtcp interval
     * for incoming messages from other session participants. It informs the rtp
     * module which later informs the rtp application about the ssrc identifier
     */
    virtual void setRtcpInitializedPkt(uint32_t ssrc);

    virtual void setCreateSenderModulePkt(uint32_t ssrc, int payloadType, const char *fileName);
    virtual void setSenderModuleCreatedPkt(uint32_t ssrc);

    virtual void setDeleteSenderModulePkt(uint32_t ssrc);
    virtual void setSenderModuleDeletedPkt(uint32_t ssrc);

    virtual void setInitializeSenderModulePkt(uint32_t ssrc, const char *fileName, int mtu);
    virtual void setSenderModuleInitializedPkt(uint32_t ssrc, int payloadType, int clockRate,
            int timeStampBase, int sequenceNumberBase);

    virtual void setSenderModuleControlPkt(uint32_t ssrc, RtpSenderControlMessage *msg);
    virtual void setSenderModuleStatusPkt(uint32_t ssrc, RtpSenderStatusMessage *msg);

    /**
     * Called by the rtp module to inform the rtcp module that the session
     * should be left.
     */
    virtual void setLeaveSessionPkt();

    /**
     * Called by the rtcp module when the rtcp bye packet has been sent
     * to the network.
     */
    virtual void setSessionLeftPkt();

    /**
     * Capsulates the outgoing RtpPacket into this RtpInnerPacket to transport
     * it within the rtp layer.
     */
    virtual void setDataOutPkt(Packet *packet);

    /**
     * Capsulates the incoming RtpPacket into this RtpInnerPacket to transport
     * it within the rtp layer.
     */
    virtual void setDataInPkt(Packet *packet, Ipv4Address address, int port);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RtpInnerPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RtpInnerPacket& obj) {obj.parsimUnpack(b);}


}  // namespace rtp
}  // namespace inet


namespace omnetpp {

template<> inline inet::rtp::RtpInnerPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::rtp::RtpInnerPacket*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __INET__RTP_RTPINNERPACKET_M_H

