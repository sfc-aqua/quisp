//
// Generated file, do not edit! Created by opp_msgtool 6.0 from inet/transportlayer/sctp/SctpHeader.msg.
//

#ifndef __INET__SCTP_SCTPHEADER_M_H
#define __INET__SCTP_SCTPHEADER_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {
namespace sctp {

class SctpHeader;
class SctpChunk;
class SctpInitChunk;
class SctpInitAckChunk;
class SctpCookieEchoChunk;
class SctpCookie;
class SctpCookieAckChunk;
class SctpDataMsg;
class SctpDataChunk;
class SctpForwardTsnChunk;
class SctpSackChunk;
class SctpAbortChunk;
class SctpHeartbeatChunk;
class SctpHeartbeatAckChunk;
class SctpShutdownChunk;
class SctpShutdownAckChunk;
class SctpShutdownCompleteChunk;
class SctpErrorChunk;
class SctpParameter;
class SctpPacketDropChunk;
class SctpStreamResetChunk;
class SctpOutgoingSsnResetRequestParameter;
class SctpIncomingSsnResetRequestParameter;
class SctpSsnTsnResetRequestParameter;
class SctpStreamResetResponseParameter;
class SctpAddStreamsRequestParameter;
class SctpResetTimer;
class SctpAuthenticationChunk;
class SctpAsconfChunk;
class SctpAsconfAckChunk;
class SctpAddIPParameter;
class SctpDeleteIPParameter;
class SctpSetPrimaryIPParameter;
class SctpSupportedExtensionsParameter;
class SctpErrorCauseParameter;
class SctpSimpleErrorCauseParameter;
class SctpSuccessIndication;
class NatMessage;

}  // namespace sctp
}  // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/networklayer/common/L3Address_m.h" // import inet.networklayer.common.L3Address

#include "inet/transportlayer/contract/TransportHeaderBase_m.h" // import inet.transportlayer.contract.TransportHeaderBase

#include "inet/transportlayer/common/CrcMode_m.h" // import inet.transportlayer.common.CrcMode

#include "inet/common/packet/Message_m.h" // import inet.common.packet.Message


namespace inet {
namespace sctp {

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:17</tt> by opp_msgtool.
 * <pre>
 * class SctpHeader extends TransportHeaderBase
 * {
 *     \@customize;
 *     // Source Port
 *     uint16_t srcPort;
 *     // Destination Port
 *     uint16_t destPort;
 *     // Verification Tag
 *     uint32_t vTag;
 *     bool checksumOk;
 *     uint32_t crc = 0;
 *     CrcMode crcMode = CRC_MODE_UNDEFINED;
 *     unsigned short headerLength = 12;
 *     abstract SctpChunk *sctpChunks[];
 * }
 * </pre>
 *
 * SctpHeader_Base is only useful if it gets subclassed, and SctpHeader is derived from it.
 * The minimum code to be written for SctpHeader is the following:
 *
 * <pre>
 * class INET_API SctpHeader : public SctpHeader_Base
 * {
 *   private:
 *     void copy(const SctpHeader& other) { ... }

 *   public:
 *     SctpHeader() : SctpHeader_Base() {}
 *     SctpHeader(const SctpHeader& other) : SctpHeader_Base(other) {copy(other);}
 *     SctpHeader& operator=(const SctpHeader& other) {if (this==&other) return *this; SctpHeader_Base::operator=(other); copy(other); return *this;}
 *     virtual SctpHeader *dup() const override {return new SctpHeader(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SctpHeader_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SctpHeader)
 * </pre>
 */
class INET_API SctpHeader_Base : public ::inet::TransportHeaderBase
{
  protected:
    uint16_t srcPort = 0;
    uint16_t destPort = 0;
    uint32_t vTag = 0;
    bool checksumOk = false;
    uint32_t crc = 0;
    ::inet::CrcMode crcMode = CRC_MODE_UNDEFINED;
    unsigned short headerLength = 12;

  private:
    void copy(const SctpHeader_Base& other);

  protected:
    bool operator==(const SctpHeader_Base&) = delete;
    // make constructors protected to avoid instantiation
    SctpHeader_Base();
    SctpHeader_Base(const SctpHeader_Base& other);
    // make assignment operator protected to force the user override it
    SctpHeader_Base& operator=(const SctpHeader_Base& other);

  public:
    virtual ~SctpHeader_Base();
    virtual SctpHeader_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SctpHeader");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint16_t getSrcPort() const;
    virtual void setSrcPort(uint16_t srcPort);

    virtual uint16_t getDestPort() const;
    virtual void setDestPort(uint16_t destPort);

    virtual uint32_t getVTag() const;
    virtual void setVTag(uint32_t vTag);

    virtual bool getChecksumOk() const;
    virtual void setChecksumOk(bool checksumOk);

    virtual uint32_t getCrc() const;
    virtual void setCrc(uint32_t crc);

    virtual ::inet::CrcMode getCrcMode() const;
    virtual void setCrcMode(::inet::CrcMode crcMode);

    virtual unsigned short getHeaderLength() const;
    virtual void setHeaderLength(unsigned short headerLength);

    virtual void setSctpChunksArraySize(size_t size) = 0;
    virtual size_t getSctpChunksArraySize() const = 0;
    virtual const SctpChunk * getSctpChunks(size_t k) const = 0;
    virtual SctpChunk * getSctpChunksForUpdate(size_t k) { handleChange();return const_cast<SctpChunk *>(const_cast<SctpHeader_Base*>(this)->getSctpChunks(k));}
    virtual void setSctpChunks(size_t k, SctpChunk * sctpChunks) = 0;
    virtual void insertSctpChunks(size_t k, SctpChunk * sctpChunks) = 0;
    [[deprecated]] void insertSctpChunks(SctpChunk * sctpChunks) {appendSctpChunks(sctpChunks);}
    virtual void appendSctpChunks(SctpChunk * sctpChunks) = 0;
    virtual void eraseSctpChunks(size_t k) = 0;
};

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:33</tt> by opp_msgtool.
 * <pre>
 * class SctpChunk extends cPacket
 * {
 *     \@packetData;
 *     // Chunk Type
 *     uint8_t sctpChunkType;
 *     uint32_t flags;
 *     unsigned short length = 0;
 *     char chunkName[];
 * }
 * </pre>
 */
class INET_API SctpChunk : public ::omnetpp::cPacket
{
  protected:
    uint8_t sctpChunkType = 0;
    uint32_t flags = 0;
    unsigned short length = 0;
    char *chunkName = nullptr;
    size_t chunkName_arraysize = 0;

  private:
    void copy(const SctpChunk& other);

  protected:
    bool operator==(const SctpChunk&) = delete;

  public:
    SctpChunk(const char *name=nullptr);
    SctpChunk(const SctpChunk& other);
    virtual ~SctpChunk();
    SctpChunk& operator=(const SctpChunk& other);
    virtual SctpChunk *dup() const override {return new SctpChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getSctpChunkType() const;
    virtual void setSctpChunkType(uint8_t sctpChunkType);

    virtual uint32_t getFlags() const;
    virtual void setFlags(uint32_t flags);

    virtual unsigned short getLength() const;
    virtual void setLength(unsigned short length);

    virtual void setChunkNameArraySize(size_t size);
    virtual size_t getChunkNameArraySize() const;
    virtual char getChunkName(size_t k) const;
    virtual void setChunkName(size_t k, char chunkName);
    virtual void insertChunkName(size_t k, char chunkName);
    [[deprecated]] void insertChunkName(char chunkName) {appendChunkName(chunkName);}
    virtual void appendChunkName(char chunkName);
    virtual void eraseChunkName(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:43</tt> by opp_msgtool.
 * <pre>
 * class SctpInitChunk extends SctpChunk
 * {
 *     // Initiate Tag
 *     uint32_t initTag;
 *     // Advertised Receiver Window
 *     uint32_t a_rwnd;
 *     // Number of Outbound Streams
 *     uint16_t noOutStreams;
 *     // Number of Inbound Streams
 *     uint16_t noInStreams;
 *     // Initial TSN
 *     uint32_t initTsn;
 *     bool forwardTsn;
 *     bool ipv4Supported;
 *     bool ipv6Supported;
 *     L3Address addresses[];
 *     uint8_t unrecognizedParameters[]; //Will be filled by the Parser, if unrecognized Parameters arrive.
 *     uint32_t msg_rwnd;
 *     uint16_t sctpChunkTypes[]; //Chunk list parameter, i.e. for SCTP AUTH
 *     uint16_t sepChunks[]; //Supported extensions parameter, i.e. for StreamReset
 *     uint16_t hmacTypes[]; //HMAC Identifier for HMAC algorithm parameter
 *     uint8_t random[]; //Random Parameter for SCTP AUTH
 * }
 * </pre>
 */
class INET_API SctpInitChunk : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t initTag = 0;
    uint32_t a_rwnd = 0;
    uint16_t noOutStreams = 0;
    uint16_t noInStreams = 0;
    uint32_t initTsn = 0;
    bool forwardTsn = false;
    bool ipv4Supported = false;
    bool ipv6Supported = false;
    ::inet::L3Address *addresses = nullptr;
    size_t addresses_arraysize = 0;
    uint8_t *unrecognizedParameters = nullptr;
    size_t unrecognizedParameters_arraysize = 0;
    uint32_t msg_rwnd = 0;
    uint16_t *sctpChunkTypes = nullptr;
    size_t sctpChunkTypes_arraysize = 0;
    uint16_t *sepChunks = nullptr;
    size_t sepChunks_arraysize = 0;
    uint16_t *hmacTypes = nullptr;
    size_t hmacTypes_arraysize = 0;
    uint8_t *random = nullptr;
    size_t random_arraysize = 0;

  private:
    void copy(const SctpInitChunk& other);

  protected:
    bool operator==(const SctpInitChunk&) = delete;

  public:
    SctpInitChunk(const char *name=nullptr);
    SctpInitChunk(const SctpInitChunk& other);
    virtual ~SctpInitChunk();
    SctpInitChunk& operator=(const SctpInitChunk& other);
    virtual SctpInitChunk *dup() const override {return new SctpInitChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getInitTag() const;
    virtual void setInitTag(uint32_t initTag);

    virtual uint32_t getA_rwnd() const;
    virtual void setA_rwnd(uint32_t a_rwnd);

    virtual uint16_t getNoOutStreams() const;
    virtual void setNoOutStreams(uint16_t noOutStreams);

    virtual uint16_t getNoInStreams() const;
    virtual void setNoInStreams(uint16_t noInStreams);

    virtual uint32_t getInitTsn() const;
    virtual void setInitTsn(uint32_t initTsn);

    virtual bool getForwardTsn() const;
    virtual void setForwardTsn(bool forwardTsn);

    virtual bool getIpv4Supported() const;
    virtual void setIpv4Supported(bool ipv4Supported);

    virtual bool getIpv6Supported() const;
    virtual void setIpv6Supported(bool ipv6Supported);

    virtual void setAddressesArraySize(size_t size);
    virtual size_t getAddressesArraySize() const;
    virtual const ::inet::L3Address& getAddresses(size_t k) const;
    virtual ::inet::L3Address& getAddressesForUpdate(size_t k) { return const_cast<::inet::L3Address&>(const_cast<SctpInitChunk*>(this)->getAddresses(k));}
    virtual void setAddresses(size_t k, const ::inet::L3Address& addresses);
    virtual void insertAddresses(size_t k, const ::inet::L3Address& addresses);
    [[deprecated]] void insertAddresses(const ::inet::L3Address& addresses) {appendAddresses(addresses);}
    virtual void appendAddresses(const ::inet::L3Address& addresses);
    virtual void eraseAddresses(size_t k);

    virtual void setUnrecognizedParametersArraySize(size_t size);
    virtual size_t getUnrecognizedParametersArraySize() const;
    virtual uint8_t getUnrecognizedParameters(size_t k) const;
    virtual void setUnrecognizedParameters(size_t k, uint8_t unrecognizedParameters);
    virtual void insertUnrecognizedParameters(size_t k, uint8_t unrecognizedParameters);
    [[deprecated]] void insertUnrecognizedParameters(uint8_t unrecognizedParameters) {appendUnrecognizedParameters(unrecognizedParameters);}
    virtual void appendUnrecognizedParameters(uint8_t unrecognizedParameters);
    virtual void eraseUnrecognizedParameters(size_t k);

    virtual uint32_t getMsg_rwnd() const;
    virtual void setMsg_rwnd(uint32_t msg_rwnd);

    virtual void setSctpChunkTypesArraySize(size_t size);
    virtual size_t getSctpChunkTypesArraySize() const;
    virtual uint16_t getSctpChunkTypes(size_t k) const;
    virtual void setSctpChunkTypes(size_t k, uint16_t sctpChunkTypes);
    virtual void insertSctpChunkTypes(size_t k, uint16_t sctpChunkTypes);
    [[deprecated]] void insertSctpChunkTypes(uint16_t sctpChunkTypes) {appendSctpChunkTypes(sctpChunkTypes);}
    virtual void appendSctpChunkTypes(uint16_t sctpChunkTypes);
    virtual void eraseSctpChunkTypes(size_t k);

    virtual void setSepChunksArraySize(size_t size);
    virtual size_t getSepChunksArraySize() const;
    virtual uint16_t getSepChunks(size_t k) const;
    virtual void setSepChunks(size_t k, uint16_t sepChunks);
    virtual void insertSepChunks(size_t k, uint16_t sepChunks);
    [[deprecated]] void insertSepChunks(uint16_t sepChunks) {appendSepChunks(sepChunks);}
    virtual void appendSepChunks(uint16_t sepChunks);
    virtual void eraseSepChunks(size_t k);

    virtual void setHmacTypesArraySize(size_t size);
    virtual size_t getHmacTypesArraySize() const;
    virtual uint16_t getHmacTypes(size_t k) const;
    virtual void setHmacTypes(size_t k, uint16_t hmacTypes);
    virtual void insertHmacTypes(size_t k, uint16_t hmacTypes);
    [[deprecated]] void insertHmacTypes(uint16_t hmacTypes) {appendHmacTypes(hmacTypes);}
    virtual void appendHmacTypes(uint16_t hmacTypes);
    virtual void eraseHmacTypes(size_t k);

    virtual void setRandomArraySize(size_t size);
    virtual size_t getRandomArraySize() const;
    virtual uint8_t getRandom(size_t k) const;
    virtual void setRandom(size_t k, uint8_t random);
    virtual void insertRandom(size_t k, uint8_t random);
    [[deprecated]] void insertRandom(uint8_t random) {appendRandom(random);}
    virtual void appendRandom(uint8_t random);
    virtual void eraseRandom(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpInitChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpInitChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:67</tt> by opp_msgtool.
 * <pre>
 * class SctpInitAckChunk extends SctpChunk
 * {
 *     // Initiate Tag
 *     uint32_t initTag;
 *     // Advertised Receiver Window
 *     uint32_t a_rwnd;
 *     // Number of Outbound Streams
 *     uint16_t noOutStreams;
 *     // Number of Inbound Streams
 *     uint16_t noInStreams;
 *     // Initial TSN
 *     uint32_t initTsn;
 *     bool forwardTsn;
 *     bool ipv4Supported;
 *     bool ipv6Supported;
 *     L3Address addresses[];
 *     char cookie[];
 *     uint8_t unrecognizedParameters[];
 *     SctpCookie *stateCookie;
 *     uint32_t msg_rwnd;
 *     uint8_t random[]; //Random Number
 *     uint16_t sctpChunkTypes[];
 *     uint16_t sepChunks[]; //Supported extensions parameter, i.e. for StreamReset
 *     uint16_t hmacTypes[];
 * }
 * </pre>
 */
class INET_API SctpInitAckChunk : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t initTag = 0;
    uint32_t a_rwnd = 0;
    uint16_t noOutStreams = 0;
    uint16_t noInStreams = 0;
    uint32_t initTsn = 0;
    bool forwardTsn = false;
    bool ipv4Supported = false;
    bool ipv6Supported = false;
    ::inet::L3Address *addresses = nullptr;
    size_t addresses_arraysize = 0;
    char *cookie = nullptr;
    size_t cookie_arraysize = 0;
    uint8_t *unrecognizedParameters = nullptr;
    size_t unrecognizedParameters_arraysize = 0;
    SctpCookie * stateCookie = nullptr;
    uint32_t msg_rwnd = 0;
    uint8_t *random = nullptr;
    size_t random_arraysize = 0;
    uint16_t *sctpChunkTypes = nullptr;
    size_t sctpChunkTypes_arraysize = 0;
    uint16_t *sepChunks = nullptr;
    size_t sepChunks_arraysize = 0;
    uint16_t *hmacTypes = nullptr;
    size_t hmacTypes_arraysize = 0;

  private:
    void copy(const SctpInitAckChunk& other);

  protected:
    bool operator==(const SctpInitAckChunk&) = delete;

  public:
    SctpInitAckChunk(const char *name=nullptr);
    SctpInitAckChunk(const SctpInitAckChunk& other);
    virtual ~SctpInitAckChunk();
    SctpInitAckChunk& operator=(const SctpInitAckChunk& other);
    virtual SctpInitAckChunk *dup() const override {return new SctpInitAckChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getInitTag() const;
    virtual void setInitTag(uint32_t initTag);

    virtual uint32_t getA_rwnd() const;
    virtual void setA_rwnd(uint32_t a_rwnd);

    virtual uint16_t getNoOutStreams() const;
    virtual void setNoOutStreams(uint16_t noOutStreams);

    virtual uint16_t getNoInStreams() const;
    virtual void setNoInStreams(uint16_t noInStreams);

    virtual uint32_t getInitTsn() const;
    virtual void setInitTsn(uint32_t initTsn);

    virtual bool getForwardTsn() const;
    virtual void setForwardTsn(bool forwardTsn);

    virtual bool getIpv4Supported() const;
    virtual void setIpv4Supported(bool ipv4Supported);

    virtual bool getIpv6Supported() const;
    virtual void setIpv6Supported(bool ipv6Supported);

    virtual void setAddressesArraySize(size_t size);
    virtual size_t getAddressesArraySize() const;
    virtual const ::inet::L3Address& getAddresses(size_t k) const;
    virtual ::inet::L3Address& getAddressesForUpdate(size_t k) { return const_cast<::inet::L3Address&>(const_cast<SctpInitAckChunk*>(this)->getAddresses(k));}
    virtual void setAddresses(size_t k, const ::inet::L3Address& addresses);
    virtual void insertAddresses(size_t k, const ::inet::L3Address& addresses);
    [[deprecated]] void insertAddresses(const ::inet::L3Address& addresses) {appendAddresses(addresses);}
    virtual void appendAddresses(const ::inet::L3Address& addresses);
    virtual void eraseAddresses(size_t k);

    virtual void setCookieArraySize(size_t size);
    virtual size_t getCookieArraySize() const;
    virtual char getCookie(size_t k) const;
    virtual void setCookie(size_t k, char cookie);
    virtual void insertCookie(size_t k, char cookie);
    [[deprecated]] void insertCookie(char cookie) {appendCookie(cookie);}
    virtual void appendCookie(char cookie);
    virtual void eraseCookie(size_t k);

    virtual void setUnrecognizedParametersArraySize(size_t size);
    virtual size_t getUnrecognizedParametersArraySize() const;
    virtual uint8_t getUnrecognizedParameters(size_t k) const;
    virtual void setUnrecognizedParameters(size_t k, uint8_t unrecognizedParameters);
    virtual void insertUnrecognizedParameters(size_t k, uint8_t unrecognizedParameters);
    [[deprecated]] void insertUnrecognizedParameters(uint8_t unrecognizedParameters) {appendUnrecognizedParameters(unrecognizedParameters);}
    virtual void appendUnrecognizedParameters(uint8_t unrecognizedParameters);
    virtual void eraseUnrecognizedParameters(size_t k);

    virtual const SctpCookie * getStateCookie() const;
    virtual SctpCookie * getStateCookieForUpdate() { return const_cast<SctpCookie *>(const_cast<SctpInitAckChunk*>(this)->getStateCookie());}
    virtual void setStateCookie(SctpCookie * stateCookie);

    virtual uint32_t getMsg_rwnd() const;
    virtual void setMsg_rwnd(uint32_t msg_rwnd);

    virtual void setRandomArraySize(size_t size);
    virtual size_t getRandomArraySize() const;
    virtual uint8_t getRandom(size_t k) const;
    virtual void setRandom(size_t k, uint8_t random);
    virtual void insertRandom(size_t k, uint8_t random);
    [[deprecated]] void insertRandom(uint8_t random) {appendRandom(random);}
    virtual void appendRandom(uint8_t random);
    virtual void eraseRandom(size_t k);

    virtual void setSctpChunkTypesArraySize(size_t size);
    virtual size_t getSctpChunkTypesArraySize() const;
    virtual uint16_t getSctpChunkTypes(size_t k) const;
    virtual void setSctpChunkTypes(size_t k, uint16_t sctpChunkTypes);
    virtual void insertSctpChunkTypes(size_t k, uint16_t sctpChunkTypes);
    [[deprecated]] void insertSctpChunkTypes(uint16_t sctpChunkTypes) {appendSctpChunkTypes(sctpChunkTypes);}
    virtual void appendSctpChunkTypes(uint16_t sctpChunkTypes);
    virtual void eraseSctpChunkTypes(size_t k);

    virtual void setSepChunksArraySize(size_t size);
    virtual size_t getSepChunksArraySize() const;
    virtual uint16_t getSepChunks(size_t k) const;
    virtual void setSepChunks(size_t k, uint16_t sepChunks);
    virtual void insertSepChunks(size_t k, uint16_t sepChunks);
    [[deprecated]] void insertSepChunks(uint16_t sepChunks) {appendSepChunks(sepChunks);}
    virtual void appendSepChunks(uint16_t sepChunks);
    virtual void eraseSepChunks(size_t k);

    virtual void setHmacTypesArraySize(size_t size);
    virtual size_t getHmacTypesArraySize() const;
    virtual uint16_t getHmacTypes(size_t k) const;
    virtual void setHmacTypes(size_t k, uint16_t hmacTypes);
    virtual void insertHmacTypes(size_t k, uint16_t hmacTypes);
    [[deprecated]] void insertHmacTypes(uint16_t hmacTypes) {appendHmacTypes(hmacTypes);}
    virtual void appendHmacTypes(uint16_t hmacTypes);
    virtual void eraseHmacTypes(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpInitAckChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpInitAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:93</tt> by opp_msgtool.
 * <pre>
 * class SctpCookieEchoChunk extends SctpChunk
 * {
 *     char cookie[];
 *     SctpCookie *stateCookie;
 *     uint8_t unrecognizedParameters[]; //for the serializer to send an Error chunk bundled with a Cookie-Echo
 * }
 * </pre>
 */
class INET_API SctpCookieEchoChunk : public ::inet::sctp::SctpChunk
{
  protected:
    char *cookie = nullptr;
    size_t cookie_arraysize = 0;
    SctpCookie * stateCookie = nullptr;
    uint8_t *unrecognizedParameters = nullptr;
    size_t unrecognizedParameters_arraysize = 0;

  private:
    void copy(const SctpCookieEchoChunk& other);

  protected:
    bool operator==(const SctpCookieEchoChunk&) = delete;

  public:
    SctpCookieEchoChunk(const char *name=nullptr);
    SctpCookieEchoChunk(const SctpCookieEchoChunk& other);
    virtual ~SctpCookieEchoChunk();
    SctpCookieEchoChunk& operator=(const SctpCookieEchoChunk& other);
    virtual SctpCookieEchoChunk *dup() const override {return new SctpCookieEchoChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setCookieArraySize(size_t size);
    virtual size_t getCookieArraySize() const;
    virtual char getCookie(size_t k) const;
    virtual void setCookie(size_t k, char cookie);
    virtual void insertCookie(size_t k, char cookie);
    [[deprecated]] void insertCookie(char cookie) {appendCookie(cookie);}
    virtual void appendCookie(char cookie);
    virtual void eraseCookie(size_t k);

    virtual const SctpCookie * getStateCookie() const;
    virtual SctpCookie * getStateCookieForUpdate() { return const_cast<SctpCookie *>(const_cast<SctpCookieEchoChunk*>(this)->getStateCookie());}
    virtual void setStateCookie(SctpCookie * stateCookie);

    virtual void setUnrecognizedParametersArraySize(size_t size);
    virtual size_t getUnrecognizedParametersArraySize() const;
    virtual uint8_t getUnrecognizedParameters(size_t k) const;
    virtual void setUnrecognizedParameters(size_t k, uint8_t unrecognizedParameters);
    virtual void insertUnrecognizedParameters(size_t k, uint8_t unrecognizedParameters);
    [[deprecated]] void insertUnrecognizedParameters(uint8_t unrecognizedParameters) {appendUnrecognizedParameters(unrecognizedParameters);}
    virtual void appendUnrecognizedParameters(uint8_t unrecognizedParameters);
    virtual void eraseUnrecognizedParameters(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpCookieEchoChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpCookieEchoChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:100</tt> by opp_msgtool.
 * <pre>
 * class SctpCookie extends cNamedObject
 * {
 *     simtime_t creationTime;
 *     uint32_t localTag;
 *     uint32_t peerTag;
 *     uint8_t localTieTag[];
 *     uint8_t peerTieTag[];
 *     uint32_t length;
 * }
 * </pre>
 */
class INET_API SctpCookie : public ::omnetpp::cNamedObject
{
  protected:
    ::omnetpp::simtime_t creationTime = SIMTIME_ZERO;
    uint32_t localTag = 0;
    uint32_t peerTag = 0;
    uint8_t *localTieTag = nullptr;
    size_t localTieTag_arraysize = 0;
    uint8_t *peerTieTag = nullptr;
    size_t peerTieTag_arraysize = 0;
    uint32_t length = 0;

  private:
    void copy(const SctpCookie& other);

  protected:
    bool operator==(const SctpCookie&) = delete;

  public:
    SctpCookie(const char *name=nullptr);
    SctpCookie(const SctpCookie& other);
    virtual ~SctpCookie();
    SctpCookie& operator=(const SctpCookie& other);
    virtual SctpCookie *dup() const override {return new SctpCookie(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual ::omnetpp::simtime_t getCreationTime() const;
    virtual void setCreationTime(::omnetpp::simtime_t creationTime);

    virtual uint32_t getLocalTag() const;
    virtual void setLocalTag(uint32_t localTag);

    virtual uint32_t getPeerTag() const;
    virtual void setPeerTag(uint32_t peerTag);

    virtual void setLocalTieTagArraySize(size_t size);
    virtual size_t getLocalTieTagArraySize() const;
    virtual uint8_t getLocalTieTag(size_t k) const;
    virtual void setLocalTieTag(size_t k, uint8_t localTieTag);
    virtual void insertLocalTieTag(size_t k, uint8_t localTieTag);
    [[deprecated]] void insertLocalTieTag(uint8_t localTieTag) {appendLocalTieTag(localTieTag);}
    virtual void appendLocalTieTag(uint8_t localTieTag);
    virtual void eraseLocalTieTag(size_t k);

    virtual void setPeerTieTagArraySize(size_t size);
    virtual size_t getPeerTieTagArraySize() const;
    virtual uint8_t getPeerTieTag(size_t k) const;
    virtual void setPeerTieTag(size_t k, uint8_t peerTieTag);
    virtual void insertPeerTieTag(size_t k, uint8_t peerTieTag);
    [[deprecated]] void insertPeerTieTag(uint8_t peerTieTag) {appendPeerTieTag(peerTieTag);}
    virtual void appendPeerTieTag(uint8_t peerTieTag);
    virtual void erasePeerTieTag(size_t k);

    virtual uint32_t getLength() const;
    virtual void setLength(uint32_t length);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpCookie& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpCookie& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:110</tt> by opp_msgtool.
 * <pre>
 * class SctpCookieAckChunk extends SctpChunk
 * {
 * }
 * </pre>
 */
class INET_API SctpCookieAckChunk : public ::inet::sctp::SctpChunk
{
  protected:

  private:
    void copy(const SctpCookieAckChunk& other);

  protected:
    bool operator==(const SctpCookieAckChunk&) = delete;

  public:
    SctpCookieAckChunk(const char *name=nullptr);
    SctpCookieAckChunk(const SctpCookieAckChunk& other);
    virtual ~SctpCookieAckChunk();
    SctpCookieAckChunk& operator=(const SctpCookieAckChunk& other);
    virtual SctpCookieAckChunk *dup() const override {return new SctpCookieAckChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpCookieAckChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpCookieAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:114</tt> by opp_msgtool.
 * <pre>
 * class SctpDataMsg extends cPacket
 * {
 *     // Chunk Flags
 *     bool eBit = 0;
 *     bool bBit = 0;
 *     simtime_t enqueuingTime;
 *     simtime_t expiryTime;
 *     uint32_t ppid;
 *     L3Address initialDestination;
 *     uint32_t msgNum;
 *     uint16_t sid;
 *     bool ordered;
 *     uint32_t booksize;
 *     uint32_t rtx;
 *     bool fragment;
 *     uint32_t prMethod;
 *     uint32_t priority;
 *     bool strReset;
 *     bool sackNow;
 * }
 * </pre>
 */
class INET_API SctpDataMsg : public ::omnetpp::cPacket
{
  protected:
    bool eBit = 0;
    bool bBit = 0;
    ::omnetpp::simtime_t enqueuingTime = SIMTIME_ZERO;
    ::omnetpp::simtime_t expiryTime = SIMTIME_ZERO;
    uint32_t ppid = 0;
    ::inet::L3Address initialDestination;
    uint32_t msgNum = 0;
    uint16_t sid = 0;
    bool ordered = false;
    uint32_t booksize = 0;
    uint32_t rtx = 0;
    bool fragment = false;
    uint32_t prMethod = 0;
    uint32_t priority = 0;
    bool strReset = false;
    bool sackNow = false;

  private:
    void copy(const SctpDataMsg& other);

  protected:
    bool operator==(const SctpDataMsg&) = delete;

  public:
    SctpDataMsg(const char *name=nullptr);
    SctpDataMsg(const SctpDataMsg& other);
    virtual ~SctpDataMsg();
    SctpDataMsg& operator=(const SctpDataMsg& other);
    virtual SctpDataMsg *dup() const override {return new SctpDataMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);

    virtual bool getBBit() const;
    virtual void setBBit(bool bBit);

    virtual ::omnetpp::simtime_t getEnqueuingTime() const;
    virtual void setEnqueuingTime(::omnetpp::simtime_t enqueuingTime);

    virtual ::omnetpp::simtime_t getExpiryTime() const;
    virtual void setExpiryTime(::omnetpp::simtime_t expiryTime);

    virtual uint32_t getPpid() const;
    virtual void setPpid(uint32_t ppid);

    virtual const ::inet::L3Address& getInitialDestination() const;
    virtual ::inet::L3Address& getInitialDestinationForUpdate() { return const_cast<::inet::L3Address&>(const_cast<SctpDataMsg*>(this)->getInitialDestination());}
    virtual void setInitialDestination(const ::inet::L3Address& initialDestination);

    virtual uint32_t getMsgNum() const;
    virtual void setMsgNum(uint32_t msgNum);

    virtual uint16_t getSid() const;
    virtual void setSid(uint16_t sid);

    virtual bool getOrdered() const;
    virtual void setOrdered(bool ordered);

    virtual uint32_t getBooksize() const;
    virtual void setBooksize(uint32_t booksize);

    virtual uint32_t getRtx() const;
    virtual void setRtx(uint32_t rtx);

    virtual bool getFragment() const;
    virtual void setFragment(bool fragment);

    virtual uint32_t getPrMethod() const;
    virtual void setPrMethod(uint32_t prMethod);

    virtual uint32_t getPriority() const;
    virtual void setPriority(uint32_t priority);

    virtual bool getStrReset() const;
    virtual void setStrReset(bool strReset);

    virtual bool getSackNow() const;
    virtual void setSackNow(bool sackNow);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpDataMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpDataMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:135</tt> by opp_msgtool.
 * <pre>
 * class SctpDataChunk extends SctpChunk
 * {
 *     // Chunk Flags
 *     bool eBit = 0;
 *     bool bBit = 0;
 *     bool uBit = 0;
 *     bool iBit = 0;
 *     // Transmission Sequence Number
 *     uint32_t tsn;
 *     // Stream identifier
 *     uint16_t sid;
 *     // Stream Sequence Number
 *     uint16_t ssn;
 *     // Payload Protocol Identifier
 *     uint32_t ppid;
 *     simtime_t enqueuingTime;
 *     simtime_t firstSendTime;
 * }
 * </pre>
 */
class INET_API SctpDataChunk : public ::inet::sctp::SctpChunk
{
  protected:
    bool eBit = 0;
    bool bBit = 0;
    bool uBit = 0;
    bool iBit = 0;
    uint32_t tsn = 0;
    uint16_t sid = 0;
    uint16_t ssn = 0;
    uint32_t ppid = 0;
    ::omnetpp::simtime_t enqueuingTime = SIMTIME_ZERO;
    ::omnetpp::simtime_t firstSendTime = SIMTIME_ZERO;

  private:
    void copy(const SctpDataChunk& other);

  protected:
    bool operator==(const SctpDataChunk&) = delete;

  public:
    SctpDataChunk(const char *name=nullptr);
    SctpDataChunk(const SctpDataChunk& other);
    virtual ~SctpDataChunk();
    SctpDataChunk& operator=(const SctpDataChunk& other);
    virtual SctpDataChunk *dup() const override {return new SctpDataChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);

    virtual bool getBBit() const;
    virtual void setBBit(bool bBit);

    virtual bool getUBit() const;
    virtual void setUBit(bool uBit);

    virtual bool getIBit() const;
    virtual void setIBit(bool iBit);

    virtual uint32_t getTsn() const;
    virtual void setTsn(uint32_t tsn);

    virtual uint16_t getSid() const;
    virtual void setSid(uint16_t sid);

    virtual uint16_t getSsn() const;
    virtual void setSsn(uint16_t ssn);

    virtual uint32_t getPpid() const;
    virtual void setPpid(uint32_t ppid);

    virtual ::omnetpp::simtime_t getEnqueuingTime() const;
    virtual void setEnqueuingTime(::omnetpp::simtime_t enqueuingTime);

    virtual ::omnetpp::simtime_t getFirstSendTime() const;
    virtual void setFirstSendTime(::omnetpp::simtime_t firstSendTime);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpDataChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpDataChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:154</tt> by opp_msgtool.
 * <pre>
 * class SctpForwardTsnChunk extends SctpChunk
 * {
 *     uint32_t newCumTsn;
 *     uint16_t sid[];
 *     short ssn[]; // set -1 in case of unordered delivery
 * }
 * </pre>
 */
class INET_API SctpForwardTsnChunk : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t newCumTsn = 0;
    uint16_t *sid = nullptr;
    size_t sid_arraysize = 0;
    short *ssn = nullptr;
    size_t ssn_arraysize = 0;

  private:
    void copy(const SctpForwardTsnChunk& other);

  protected:
    bool operator==(const SctpForwardTsnChunk&) = delete;

  public:
    SctpForwardTsnChunk(const char *name=nullptr);
    SctpForwardTsnChunk(const SctpForwardTsnChunk& other);
    virtual ~SctpForwardTsnChunk();
    SctpForwardTsnChunk& operator=(const SctpForwardTsnChunk& other);
    virtual SctpForwardTsnChunk *dup() const override {return new SctpForwardTsnChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getNewCumTsn() const;
    virtual void setNewCumTsn(uint32_t newCumTsn);

    virtual void setSidArraySize(size_t size);
    virtual size_t getSidArraySize() const;
    virtual uint16_t getSid(size_t k) const;
    virtual void setSid(size_t k, uint16_t sid);
    virtual void insertSid(size_t k, uint16_t sid);
    [[deprecated]] void insertSid(uint16_t sid) {appendSid(sid);}
    virtual void appendSid(uint16_t sid);
    virtual void eraseSid(size_t k);

    virtual void setSsnArraySize(size_t size);
    virtual size_t getSsnArraySize() const;
    virtual short getSsn(size_t k) const;
    virtual void setSsn(size_t k, short ssn);
    virtual void insertSsn(size_t k, short ssn);
    [[deprecated]] void insertSsn(short ssn) {appendSsn(ssn);}
    virtual void appendSsn(short ssn);
    virtual void eraseSsn(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpForwardTsnChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpForwardTsnChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:161</tt> by opp_msgtool.
 * <pre>
 * class SctpSackChunk extends SctpChunk
 * {
 *     // Cumulative TSN Ack
 *     uint32_t cumTsnAck;
 *     // Advertised Receiver Window Credit
 *     uint32_t a_rwnd;
 *     // Number of Gap Ack Blocks
 *     uint16_t numGaps;
 *     // Number of Non-Revokable Gap Ack Blocks
 *     uint16_t numNrGaps;
 *     // Number of Duplicate TSNs
 *     uint16_t numDupTsns;
 *     // Start and End of Gap Ack Blocks
 *     bool isNrSack;
 *     uint32_t gapStart[];
 *     uint32_t gapStop[];
 *     uint32_t dupTsns[];
 *     uint32_t sackSeqNum = 0;
 *     uint32_t nrGapStart[];
 *     uint32_t nrGapStop[];
 *     uint32_t msg_rwnd;
 *     uint8_t dacPacketsRcvd = 0;
 *     bool nrSubtractRGaps = false;
 * }
 * </pre>
 */
class INET_API SctpSackChunk : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t cumTsnAck = 0;
    uint32_t a_rwnd = 0;
    uint16_t numGaps = 0;
    uint16_t numNrGaps = 0;
    uint16_t numDupTsns = 0;
    bool isNrSack_ = false;
    uint32_t *gapStart = nullptr;
    size_t gapStart_arraysize = 0;
    uint32_t *gapStop = nullptr;
    size_t gapStop_arraysize = 0;
    uint32_t *dupTsns = nullptr;
    size_t dupTsns_arraysize = 0;
    uint32_t sackSeqNum = 0;
    uint32_t *nrGapStart = nullptr;
    size_t nrGapStart_arraysize = 0;
    uint32_t *nrGapStop = nullptr;
    size_t nrGapStop_arraysize = 0;
    uint32_t msg_rwnd = 0;
    uint8_t dacPacketsRcvd = 0;
    bool nrSubtractRGaps = false;

  private:
    void copy(const SctpSackChunk& other);

  protected:
    bool operator==(const SctpSackChunk&) = delete;

  public:
    SctpSackChunk(const char *name=nullptr);
    SctpSackChunk(const SctpSackChunk& other);
    virtual ~SctpSackChunk();
    SctpSackChunk& operator=(const SctpSackChunk& other);
    virtual SctpSackChunk *dup() const override {return new SctpSackChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getCumTsnAck() const;
    virtual void setCumTsnAck(uint32_t cumTsnAck);

    virtual uint32_t getA_rwnd() const;
    virtual void setA_rwnd(uint32_t a_rwnd);

    virtual uint16_t getNumGaps() const;
    virtual void setNumGaps(uint16_t numGaps);

    virtual uint16_t getNumNrGaps() const;
    virtual void setNumNrGaps(uint16_t numNrGaps);

    virtual uint16_t getNumDupTsns() const;
    virtual void setNumDupTsns(uint16_t numDupTsns);

    virtual bool isNrSack() const;
    virtual void setIsNrSack(bool isNrSack);

    virtual void setGapStartArraySize(size_t size);
    virtual size_t getGapStartArraySize() const;
    virtual uint32_t getGapStart(size_t k) const;
    virtual void setGapStart(size_t k, uint32_t gapStart);
    virtual void insertGapStart(size_t k, uint32_t gapStart);
    [[deprecated]] void insertGapStart(uint32_t gapStart) {appendGapStart(gapStart);}
    virtual void appendGapStart(uint32_t gapStart);
    virtual void eraseGapStart(size_t k);

    virtual void setGapStopArraySize(size_t size);
    virtual size_t getGapStopArraySize() const;
    virtual uint32_t getGapStop(size_t k) const;
    virtual void setGapStop(size_t k, uint32_t gapStop);
    virtual void insertGapStop(size_t k, uint32_t gapStop);
    [[deprecated]] void insertGapStop(uint32_t gapStop) {appendGapStop(gapStop);}
    virtual void appendGapStop(uint32_t gapStop);
    virtual void eraseGapStop(size_t k);

    virtual void setDupTsnsArraySize(size_t size);
    virtual size_t getDupTsnsArraySize() const;
    virtual uint32_t getDupTsns(size_t k) const;
    virtual void setDupTsns(size_t k, uint32_t dupTsns);
    virtual void insertDupTsns(size_t k, uint32_t dupTsns);
    [[deprecated]] void insertDupTsns(uint32_t dupTsns) {appendDupTsns(dupTsns);}
    virtual void appendDupTsns(uint32_t dupTsns);
    virtual void eraseDupTsns(size_t k);

    virtual uint32_t getSackSeqNum() const;
    virtual void setSackSeqNum(uint32_t sackSeqNum);

    virtual void setNrGapStartArraySize(size_t size);
    virtual size_t getNrGapStartArraySize() const;
    virtual uint32_t getNrGapStart(size_t k) const;
    virtual void setNrGapStart(size_t k, uint32_t nrGapStart);
    virtual void insertNrGapStart(size_t k, uint32_t nrGapStart);
    [[deprecated]] void insertNrGapStart(uint32_t nrGapStart) {appendNrGapStart(nrGapStart);}
    virtual void appendNrGapStart(uint32_t nrGapStart);
    virtual void eraseNrGapStart(size_t k);

    virtual void setNrGapStopArraySize(size_t size);
    virtual size_t getNrGapStopArraySize() const;
    virtual uint32_t getNrGapStop(size_t k) const;
    virtual void setNrGapStop(size_t k, uint32_t nrGapStop);
    virtual void insertNrGapStop(size_t k, uint32_t nrGapStop);
    [[deprecated]] void insertNrGapStop(uint32_t nrGapStop) {appendNrGapStop(nrGapStop);}
    virtual void appendNrGapStop(uint32_t nrGapStop);
    virtual void eraseNrGapStop(size_t k);

    virtual uint32_t getMsg_rwnd() const;
    virtual void setMsg_rwnd(uint32_t msg_rwnd);

    virtual uint8_t getDacPacketsRcvd() const;
    virtual void setDacPacketsRcvd(uint8_t dacPacketsRcvd);

    virtual bool getNrSubtractRGaps() const;
    virtual void setNrSubtractRGaps(bool nrSubtractRGaps);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpSackChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpSackChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:186</tt> by opp_msgtool.
 * <pre>
 * class SctpAbortChunk extends SctpChunk
 * {
 *     // Chunk Flags
 *     bool T_Bit = 0;
 * }
 * </pre>
 */
class INET_API SctpAbortChunk : public ::inet::sctp::SctpChunk
{
  protected:
    bool T_Bit = 0;

  private:
    void copy(const SctpAbortChunk& other);

  protected:
    bool operator==(const SctpAbortChunk&) = delete;

  public:
    SctpAbortChunk(const char *name=nullptr);
    SctpAbortChunk(const SctpAbortChunk& other);
    virtual ~SctpAbortChunk();
    SctpAbortChunk& operator=(const SctpAbortChunk& other);
    virtual SctpAbortChunk *dup() const override {return new SctpAbortChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getT_Bit() const;
    virtual void setT_Bit(bool T_Bit);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpAbortChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpAbortChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:192</tt> by opp_msgtool.
 * <pre>
 * class SctpHeartbeatChunk extends SctpChunk
 * {
 *     L3Address remoteAddr;
 *     simtime_t timeField;
 *     char info[];
 * }
 * </pre>
 */
class INET_API SctpHeartbeatChunk : public ::inet::sctp::SctpChunk
{
  protected:
    ::inet::L3Address remoteAddr;
    ::omnetpp::simtime_t timeField = SIMTIME_ZERO;
    char *info = nullptr;
    size_t info_arraysize = 0;

  private:
    void copy(const SctpHeartbeatChunk& other);

  protected:
    bool operator==(const SctpHeartbeatChunk&) = delete;

  public:
    SctpHeartbeatChunk(const char *name=nullptr);
    SctpHeartbeatChunk(const SctpHeartbeatChunk& other);
    virtual ~SctpHeartbeatChunk();
    SctpHeartbeatChunk& operator=(const SctpHeartbeatChunk& other);
    virtual SctpHeartbeatChunk *dup() const override {return new SctpHeartbeatChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::L3Address& getRemoteAddr() const;
    virtual ::inet::L3Address& getRemoteAddrForUpdate() { return const_cast<::inet::L3Address&>(const_cast<SctpHeartbeatChunk*>(this)->getRemoteAddr());}
    virtual void setRemoteAddr(const ::inet::L3Address& remoteAddr);

    virtual ::omnetpp::simtime_t getTimeField() const;
    virtual void setTimeField(::omnetpp::simtime_t timeField);

    virtual void setInfoArraySize(size_t size);
    virtual size_t getInfoArraySize() const;
    virtual char getInfo(size_t k) const;
    virtual void setInfo(size_t k, char info);
    virtual void insertInfo(size_t k, char info);
    [[deprecated]] void insertInfo(char info) {appendInfo(info);}
    virtual void appendInfo(char info);
    virtual void eraseInfo(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpHeartbeatChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpHeartbeatChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:199</tt> by opp_msgtool.
 * <pre>
 * class SctpHeartbeatAckChunk extends SctpChunk
 * {
 *     L3Address remoteAddr;
 *     simtime_t timeField;
 *     char info[];
 * }
 * </pre>
 */
class INET_API SctpHeartbeatAckChunk : public ::inet::sctp::SctpChunk
{
  protected:
    ::inet::L3Address remoteAddr;
    ::omnetpp::simtime_t timeField = SIMTIME_ZERO;
    char *info = nullptr;
    size_t info_arraysize = 0;

  private:
    void copy(const SctpHeartbeatAckChunk& other);

  protected:
    bool operator==(const SctpHeartbeatAckChunk&) = delete;

  public:
    SctpHeartbeatAckChunk(const char *name=nullptr);
    SctpHeartbeatAckChunk(const SctpHeartbeatAckChunk& other);
    virtual ~SctpHeartbeatAckChunk();
    SctpHeartbeatAckChunk& operator=(const SctpHeartbeatAckChunk& other);
    virtual SctpHeartbeatAckChunk *dup() const override {return new SctpHeartbeatAckChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::L3Address& getRemoteAddr() const;
    virtual ::inet::L3Address& getRemoteAddrForUpdate() { return const_cast<::inet::L3Address&>(const_cast<SctpHeartbeatAckChunk*>(this)->getRemoteAddr());}
    virtual void setRemoteAddr(const ::inet::L3Address& remoteAddr);

    virtual ::omnetpp::simtime_t getTimeField() const;
    virtual void setTimeField(::omnetpp::simtime_t timeField);

    virtual void setInfoArraySize(size_t size);
    virtual size_t getInfoArraySize() const;
    virtual char getInfo(size_t k) const;
    virtual void setInfo(size_t k, char info);
    virtual void insertInfo(size_t k, char info);
    [[deprecated]] void insertInfo(char info) {appendInfo(info);}
    virtual void appendInfo(char info);
    virtual void eraseInfo(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpHeartbeatAckChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpHeartbeatAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:206</tt> by opp_msgtool.
 * <pre>
 * class SctpShutdownChunk extends SctpChunk
 * {
 *     uint32_t cumTsnAck;
 * }
 * </pre>
 */
class INET_API SctpShutdownChunk : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t cumTsnAck = 0;

  private:
    void copy(const SctpShutdownChunk& other);

  protected:
    bool operator==(const SctpShutdownChunk&) = delete;

  public:
    SctpShutdownChunk(const char *name=nullptr);
    SctpShutdownChunk(const SctpShutdownChunk& other);
    virtual ~SctpShutdownChunk();
    SctpShutdownChunk& operator=(const SctpShutdownChunk& other);
    virtual SctpShutdownChunk *dup() const override {return new SctpShutdownChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getCumTsnAck() const;
    virtual void setCumTsnAck(uint32_t cumTsnAck);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpShutdownChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpShutdownChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:211</tt> by opp_msgtool.
 * <pre>
 * class SctpShutdownAckChunk extends SctpChunk
 * {
 * }
 * </pre>
 */
class INET_API SctpShutdownAckChunk : public ::inet::sctp::SctpChunk
{
  protected:

  private:
    void copy(const SctpShutdownAckChunk& other);

  protected:
    bool operator==(const SctpShutdownAckChunk&) = delete;

  public:
    SctpShutdownAckChunk(const char *name=nullptr);
    SctpShutdownAckChunk(const SctpShutdownAckChunk& other);
    virtual ~SctpShutdownAckChunk();
    SctpShutdownAckChunk& operator=(const SctpShutdownAckChunk& other);
    virtual SctpShutdownAckChunk *dup() const override {return new SctpShutdownAckChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpShutdownAckChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpShutdownAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:215</tt> by opp_msgtool.
 * <pre>
 * class SctpShutdownCompleteChunk extends SctpChunk
 * {
 *     bool TBit = 0;
 * }
 * </pre>
 */
class INET_API SctpShutdownCompleteChunk : public ::inet::sctp::SctpChunk
{
  protected:
    bool TBit = 0;

  private:
    void copy(const SctpShutdownCompleteChunk& other);

  protected:
    bool operator==(const SctpShutdownCompleteChunk&) = delete;

  public:
    SctpShutdownCompleteChunk(const char *name=nullptr);
    SctpShutdownCompleteChunk(const SctpShutdownCompleteChunk& other);
    virtual ~SctpShutdownCompleteChunk();
    SctpShutdownCompleteChunk& operator=(const SctpShutdownCompleteChunk& other);
    virtual SctpShutdownCompleteChunk *dup() const override {return new SctpShutdownCompleteChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getTBit() const;
    virtual void setTBit(bool TBit);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpShutdownCompleteChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpShutdownCompleteChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:220</tt> by opp_msgtool.
 * <pre>
 * class SctpErrorChunk extends SctpChunk
 * {
 *     \@customize;
 *     bool TBit = 0;
 *     bool MBit = 0;
 *     abstract SctpParameter *parameters[];
 * }
 * </pre>
 *
 * SctpErrorChunk_Base is only useful if it gets subclassed, and SctpErrorChunk is derived from it.
 * The minimum code to be written for SctpErrorChunk is the following:
 *
 * <pre>
 * class INET_API SctpErrorChunk : public SctpErrorChunk_Base
 * {
 *   private:
 *     void copy(const SctpErrorChunk& other) { ... }

 *   public:
 *     SctpErrorChunk(const char *name=nullptr) : SctpErrorChunk_Base(name) {}
 *     SctpErrorChunk(const SctpErrorChunk& other) : SctpErrorChunk_Base(other) {copy(other);}
 *     SctpErrorChunk& operator=(const SctpErrorChunk& other) {if (this==&other) return *this; SctpErrorChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SctpErrorChunk *dup() const override {return new SctpErrorChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SctpErrorChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SctpErrorChunk)
 * </pre>
 */
class INET_API SctpErrorChunk_Base : public ::inet::sctp::SctpChunk
{
  protected:
    bool TBit = 0;
    bool MBit = 0;

  private:
    void copy(const SctpErrorChunk_Base& other);

  protected:
    bool operator==(const SctpErrorChunk_Base&) = delete;
    // make constructors protected to avoid instantiation
    SctpErrorChunk_Base(const char *name=nullptr);
    SctpErrorChunk_Base(const SctpErrorChunk_Base& other);
    // make assignment operator protected to force the user override it
    SctpErrorChunk_Base& operator=(const SctpErrorChunk_Base& other);

  public:
    virtual ~SctpErrorChunk_Base();
    virtual SctpErrorChunk_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SctpErrorChunk");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getTBit() const;
    virtual void setTBit(bool TBit);

    virtual bool getMBit() const;
    virtual void setMBit(bool MBit);

    virtual void setParametersArraySize(size_t size) = 0;
    virtual size_t getParametersArraySize() const = 0;
    virtual const SctpParameter * getParameters(size_t k) const = 0;
    virtual SctpParameter * getParametersForUpdate(size_t k) { return const_cast<SctpParameter *>(const_cast<SctpErrorChunk_Base*>(this)->getParameters(k));}
    virtual void setParameters(size_t k, SctpParameter * parameters) = 0;
    virtual void insertParameters(size_t k, SctpParameter * parameters) = 0;
    [[deprecated]] void insertParameters(SctpParameter * parameters) {appendParameters(parameters);}
    virtual void appendParameters(SctpParameter * parameters) = 0;
    virtual void eraseParameters(size_t k) = 0;
};

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:228</tt> by opp_msgtool.
 * <pre>
 * class SctpParameter extends cPacket
 * {
 *     \@packetData;
 *     uint16_t parameterType;
 * }
 * </pre>
 */
class INET_API SctpParameter : public ::omnetpp::cPacket
{
  protected:
    uint16_t parameterType = 0;

  private:
    void copy(const SctpParameter& other);

  protected:
    bool operator==(const SctpParameter&) = delete;

  public:
    SctpParameter(const char *name=nullptr);
    SctpParameter(const SctpParameter& other);
    virtual ~SctpParameter();
    SctpParameter& operator=(const SctpParameter& other);
    virtual SctpParameter *dup() const override {return new SctpParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint16_t getParameterType() const;
    virtual void setParameterType(uint16_t parameterType);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:234</tt> by opp_msgtool.
 * <pre>
 * class SctpPacketDropChunk extends SctpChunk
 * {
 *     bool cFlag;
 *     bool tFlag;
 *     bool bFlag;
 *     bool mFlag;
 *     uint32_t maxRwnd;
 *     uint32_t queuedData;
 *     uint16_t truncLength;
 * }
 * </pre>
 */
class INET_API SctpPacketDropChunk : public ::inet::sctp::SctpChunk
{
  protected:
    bool cFlag = false;
    bool tFlag = false;
    bool bFlag = false;
    bool mFlag = false;
    uint32_t maxRwnd = 0;
    uint32_t queuedData = 0;
    uint16_t truncLength = 0;

  private:
    void copy(const SctpPacketDropChunk& other);

  protected:
    bool operator==(const SctpPacketDropChunk&) = delete;

  public:
    SctpPacketDropChunk(const char *name=nullptr);
    SctpPacketDropChunk(const SctpPacketDropChunk& other);
    virtual ~SctpPacketDropChunk();
    SctpPacketDropChunk& operator=(const SctpPacketDropChunk& other);
    virtual SctpPacketDropChunk *dup() const override {return new SctpPacketDropChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getCFlag() const;
    virtual void setCFlag(bool cFlag);

    virtual bool getTFlag() const;
    virtual void setTFlag(bool tFlag);

    virtual bool getBFlag() const;
    virtual void setBFlag(bool bFlag);

    virtual bool getMFlag() const;
    virtual void setMFlag(bool mFlag);

    virtual uint32_t getMaxRwnd() const;
    virtual void setMaxRwnd(uint32_t maxRwnd);

    virtual uint32_t getQueuedData() const;
    virtual void setQueuedData(uint32_t queuedData);

    virtual uint16_t getTruncLength() const;
    virtual void setTruncLength(uint16_t truncLength);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpPacketDropChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpPacketDropChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:245</tt> by opp_msgtool.
 * <pre>
 * class SctpStreamResetChunk extends SctpChunk
 * {
 *     \@customize;
 *     abstract SctpParameter *parameters[];
 * }
 * </pre>
 *
 * SctpStreamResetChunk_Base is only useful if it gets subclassed, and SctpStreamResetChunk is derived from it.
 * The minimum code to be written for SctpStreamResetChunk is the following:
 *
 * <pre>
 * class INET_API SctpStreamResetChunk : public SctpStreamResetChunk_Base
 * {
 *   private:
 *     void copy(const SctpStreamResetChunk& other) { ... }

 *   public:
 *     SctpStreamResetChunk(const char *name=nullptr) : SctpStreamResetChunk_Base(name) {}
 *     SctpStreamResetChunk(const SctpStreamResetChunk& other) : SctpStreamResetChunk_Base(other) {copy(other);}
 *     SctpStreamResetChunk& operator=(const SctpStreamResetChunk& other) {if (this==&other) return *this; SctpStreamResetChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SctpStreamResetChunk *dup() const override {return new SctpStreamResetChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SctpStreamResetChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SctpStreamResetChunk)
 * </pre>
 */
class INET_API SctpStreamResetChunk_Base : public ::inet::sctp::SctpChunk
{
  protected:

  private:
    void copy(const SctpStreamResetChunk_Base& other);

  protected:
    bool operator==(const SctpStreamResetChunk_Base&) = delete;
    // make constructors protected to avoid instantiation
    SctpStreamResetChunk_Base(const char *name=nullptr);
    SctpStreamResetChunk_Base(const SctpStreamResetChunk_Base& other);
    // make assignment operator protected to force the user override it
    SctpStreamResetChunk_Base& operator=(const SctpStreamResetChunk_Base& other);

  public:
    virtual ~SctpStreamResetChunk_Base();
    virtual SctpStreamResetChunk_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SctpStreamResetChunk");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setParametersArraySize(size_t size) = 0;
    virtual size_t getParametersArraySize() const = 0;
    virtual const SctpParameter * getParameters(size_t k) const = 0;
    virtual SctpParameter * getParametersForUpdate(size_t k) { return const_cast<SctpParameter *>(const_cast<SctpStreamResetChunk_Base*>(this)->getParameters(k));}
    virtual void setParameters(size_t k, SctpParameter * parameters) = 0;
    virtual void insertParameters(size_t k, SctpParameter * parameters) = 0;
    [[deprecated]] void insertParameters(SctpParameter * parameters) {appendParameters(parameters);}
    virtual void appendParameters(SctpParameter * parameters) = 0;
    virtual void eraseParameters(size_t k) = 0;
};

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:251</tt> by opp_msgtool.
 * <pre>
 * class SctpOutgoingSsnResetRequestParameter extends SctpParameter
 * {
 *     uint32_t srReqSn; //Stream Reset Request Sequence Number: initialized with the initial TSN, then incremented
 *     uint32_t srResSn; //Stream Reset Response Sequence Number
 *     uint32_t lastTsn; //Senders last assigned TSN
 *     uint16_t streamNumbers[];
 * }
 * </pre>
 */
class INET_API SctpOutgoingSsnResetRequestParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t srReqSn = 0;
    uint32_t srResSn = 0;
    uint32_t lastTsn = 0;
    uint16_t *streamNumbers = nullptr;
    size_t streamNumbers_arraysize = 0;

  private:
    void copy(const SctpOutgoingSsnResetRequestParameter& other);

  protected:
    bool operator==(const SctpOutgoingSsnResetRequestParameter&) = delete;

  public:
    SctpOutgoingSsnResetRequestParameter(const char *name=nullptr);
    SctpOutgoingSsnResetRequestParameter(const SctpOutgoingSsnResetRequestParameter& other);
    virtual ~SctpOutgoingSsnResetRequestParameter();
    SctpOutgoingSsnResetRequestParameter& operator=(const SctpOutgoingSsnResetRequestParameter& other);
    virtual SctpOutgoingSsnResetRequestParameter *dup() const override {return new SctpOutgoingSsnResetRequestParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getSrReqSn() const;
    virtual void setSrReqSn(uint32_t srReqSn);

    virtual uint32_t getSrResSn() const;
    virtual void setSrResSn(uint32_t srResSn);

    virtual uint32_t getLastTsn() const;
    virtual void setLastTsn(uint32_t lastTsn);

    virtual void setStreamNumbersArraySize(size_t size);
    virtual size_t getStreamNumbersArraySize() const;
    virtual uint16_t getStreamNumbers(size_t k) const;
    virtual void setStreamNumbers(size_t k, uint16_t streamNumbers);
    virtual void insertStreamNumbers(size_t k, uint16_t streamNumbers);
    [[deprecated]] void insertStreamNumbers(uint16_t streamNumbers) {appendStreamNumbers(streamNumbers);}
    virtual void appendStreamNumbers(uint16_t streamNumbers);
    virtual void eraseStreamNumbers(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpOutgoingSsnResetRequestParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpOutgoingSsnResetRequestParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:259</tt> by opp_msgtool.
 * <pre>
 * class SctpIncomingSsnResetRequestParameter extends SctpParameter
 * {
 *     \@customize;
 *     uint32_t srReqSn; //Stream Reset Request Sequence Number
 *     uint16_t streamNumbers[];
 * }
 * </pre>
 *
 * SctpIncomingSsnResetRequestParameter_Base is only useful if it gets subclassed, and SctpIncomingSsnResetRequestParameter is derived from it.
 * The minimum code to be written for SctpIncomingSsnResetRequestParameter is the following:
 *
 * <pre>
 * class INET_API SctpIncomingSsnResetRequestParameter : public SctpIncomingSsnResetRequestParameter_Base
 * {
 *   private:
 *     void copy(const SctpIncomingSsnResetRequestParameter& other) { ... }

 *   public:
 *     SctpIncomingSsnResetRequestParameter(const char *name=nullptr) : SctpIncomingSsnResetRequestParameter_Base(name) {}
 *     SctpIncomingSsnResetRequestParameter(const SctpIncomingSsnResetRequestParameter& other) : SctpIncomingSsnResetRequestParameter_Base(other) {copy(other);}
 *     SctpIncomingSsnResetRequestParameter& operator=(const SctpIncomingSsnResetRequestParameter& other) {if (this==&other) return *this; SctpIncomingSsnResetRequestParameter_Base::operator=(other); copy(other); return *this;}
 *     virtual SctpIncomingSsnResetRequestParameter *dup() const override {return new SctpIncomingSsnResetRequestParameter(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SctpIncomingSsnResetRequestParameter_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SctpIncomingSsnResetRequestParameter)
 * </pre>
 */
class INET_API SctpIncomingSsnResetRequestParameter_Base : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t srReqSn = 0;
    uint16_t *streamNumbers = nullptr;
    size_t streamNumbers_arraysize = 0;

  private:
    void copy(const SctpIncomingSsnResetRequestParameter_Base& other);

  protected:
    bool operator==(const SctpIncomingSsnResetRequestParameter_Base&) = delete;
    // make constructors protected to avoid instantiation
    SctpIncomingSsnResetRequestParameter_Base(const char *name=nullptr);
    SctpIncomingSsnResetRequestParameter_Base(const SctpIncomingSsnResetRequestParameter_Base& other);
    // make assignment operator protected to force the user override it
    SctpIncomingSsnResetRequestParameter_Base& operator=(const SctpIncomingSsnResetRequestParameter_Base& other);

  public:
    virtual ~SctpIncomingSsnResetRequestParameter_Base();
    virtual SctpIncomingSsnResetRequestParameter_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SctpIncomingSsnResetRequestParameter");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getSrReqSn() const;
    virtual void setSrReqSn(uint32_t srReqSn);

    virtual void setStreamNumbersArraySize(size_t size);
    virtual size_t getStreamNumbersArraySize() const;
    virtual uint16_t getStreamNumbers(size_t k) const;
    virtual void setStreamNumbers(size_t k, uint16_t streamNumbers);
    virtual void insertStreamNumbers(size_t k, uint16_t streamNumbers);
    [[deprecated]] void insertStreamNumbers(uint16_t streamNumbers) {appendStreamNumbers(streamNumbers);}
    virtual void appendStreamNumbers(uint16_t streamNumbers);
    virtual void eraseStreamNumbers(size_t k);
};

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:266</tt> by opp_msgtool.
 * <pre>
 * class SctpSsnTsnResetRequestParameter extends SctpParameter
 * {
 *     uint32_t srReqSn; //Stream Reset Request Sequence Number
 * }
 * </pre>
 */
class INET_API SctpSsnTsnResetRequestParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t srReqSn = 0;

  private:
    void copy(const SctpSsnTsnResetRequestParameter& other);

  protected:
    bool operator==(const SctpSsnTsnResetRequestParameter&) = delete;

  public:
    SctpSsnTsnResetRequestParameter(const char *name=nullptr);
    SctpSsnTsnResetRequestParameter(const SctpSsnTsnResetRequestParameter& other);
    virtual ~SctpSsnTsnResetRequestParameter();
    SctpSsnTsnResetRequestParameter& operator=(const SctpSsnTsnResetRequestParameter& other);
    virtual SctpSsnTsnResetRequestParameter *dup() const override {return new SctpSsnTsnResetRequestParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getSrReqSn() const;
    virtual void setSrReqSn(uint32_t srReqSn);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpSsnTsnResetRequestParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpSsnTsnResetRequestParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:271</tt> by opp_msgtool.
 * <pre>
 * class SctpStreamResetResponseParameter extends SctpParameter
 * {
 *     uint32_t srResSn; //Stream Reset Response Sequence Number
 *     uint32_t result;
 *     uint32_t sendersNextTsn = 0;
 *     uint32_t receiversNextTsn = 0;
 * }
 * </pre>
 */
class INET_API SctpStreamResetResponseParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t srResSn = 0;
    uint32_t result = 0;
    uint32_t sendersNextTsn = 0;
    uint32_t receiversNextTsn = 0;

  private:
    void copy(const SctpStreamResetResponseParameter& other);

  protected:
    bool operator==(const SctpStreamResetResponseParameter&) = delete;

  public:
    SctpStreamResetResponseParameter(const char *name=nullptr);
    SctpStreamResetResponseParameter(const SctpStreamResetResponseParameter& other);
    virtual ~SctpStreamResetResponseParameter();
    SctpStreamResetResponseParameter& operator=(const SctpStreamResetResponseParameter& other);
    virtual SctpStreamResetResponseParameter *dup() const override {return new SctpStreamResetResponseParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getSrResSn() const;
    virtual void setSrResSn(uint32_t srResSn);

    virtual uint32_t getResult() const;
    virtual void setResult(uint32_t result);

    virtual uint32_t getSendersNextTsn() const;
    virtual void setSendersNextTsn(uint32_t sendersNextTsn);

    virtual uint32_t getReceiversNextTsn() const;
    virtual void setReceiversNextTsn(uint32_t receiversNextTsn);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpStreamResetResponseParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpStreamResetResponseParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:279</tt> by opp_msgtool.
 * <pre>
 * class SctpAddStreamsRequestParameter extends SctpParameter
 * {
 *     uint32_t srReqSn; //Stream Reset Request Sequence Number
 *     uint16_t numberOfStreams;
 *     uint16_t reserved = 0;
 * }
 * </pre>
 */
class INET_API SctpAddStreamsRequestParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t srReqSn = 0;
    uint16_t numberOfStreams = 0;
    uint16_t reserved = 0;

  private:
    void copy(const SctpAddStreamsRequestParameter& other);

  protected:
    bool operator==(const SctpAddStreamsRequestParameter&) = delete;

  public:
    SctpAddStreamsRequestParameter(const char *name=nullptr);
    SctpAddStreamsRequestParameter(const SctpAddStreamsRequestParameter& other);
    virtual ~SctpAddStreamsRequestParameter();
    SctpAddStreamsRequestParameter& operator=(const SctpAddStreamsRequestParameter& other);
    virtual SctpAddStreamsRequestParameter *dup() const override {return new SctpAddStreamsRequestParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getSrReqSn() const;
    virtual void setSrReqSn(uint32_t srReqSn);

    virtual uint16_t getNumberOfStreams() const;
    virtual void setNumberOfStreams(uint16_t numberOfStreams);

    virtual uint16_t getReserved() const;
    virtual void setReserved(uint16_t reserved);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpAddStreamsRequestParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpAddStreamsRequestParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:286</tt> by opp_msgtool.
 * <pre>
 * class SctpResetTimer extends cPacket
 * {
 *     uint32_t inSN; //Stream Reset Response Sequence Number for Incoming Reset Request
 *     bool inAcked;   // false, when timer is running for the Reset Response Sequence Number, true otherwise
 *     uint32_t outSN; //Stream Reset Response Sequence Number for Outgoing Reset Request
 *     bool outAcked;
 * }
 * </pre>
 */
class INET_API SctpResetTimer : public ::omnetpp::cPacket
{
  protected:
    uint32_t inSN = 0;
    bool inAcked = false;
    uint32_t outSN = 0;
    bool outAcked = false;

  private:
    void copy(const SctpResetTimer& other);

  protected:
    bool operator==(const SctpResetTimer&) = delete;

  public:
    SctpResetTimer(const char *name=nullptr);
    SctpResetTimer(const SctpResetTimer& other);
    virtual ~SctpResetTimer();
    SctpResetTimer& operator=(const SctpResetTimer& other);
    virtual SctpResetTimer *dup() const override {return new SctpResetTimer(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getInSN() const;
    virtual void setInSN(uint32_t inSN);

    virtual bool getInAcked() const;
    virtual void setInAcked(bool inAcked);

    virtual uint32_t getOutSN() const;
    virtual void setOutSN(uint32_t outSN);

    virtual bool getOutAcked() const;
    virtual void setOutAcked(bool outAcked);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpResetTimer& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpResetTimer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:294</tt> by opp_msgtool.
 * <pre>
 * class SctpAuthenticationChunk extends SctpChunk
 * {
 *     uint16_t sharedKey;
 *     uint16_t hMacIdentifier;
 *     bool hMacOk;
 *     uint32_t HMAC[];
 * }
 * </pre>
 */
class INET_API SctpAuthenticationChunk : public ::inet::sctp::SctpChunk
{
  protected:
    uint16_t sharedKey = 0;
    uint16_t hMacIdentifier = 0;
    bool hMacOk = false;
    uint32_t *HMAC = nullptr;
    size_t HMAC_arraysize = 0;

  private:
    void copy(const SctpAuthenticationChunk& other);

  protected:
    bool operator==(const SctpAuthenticationChunk&) = delete;

  public:
    SctpAuthenticationChunk(const char *name=nullptr);
    SctpAuthenticationChunk(const SctpAuthenticationChunk& other);
    virtual ~SctpAuthenticationChunk();
    SctpAuthenticationChunk& operator=(const SctpAuthenticationChunk& other);
    virtual SctpAuthenticationChunk *dup() const override {return new SctpAuthenticationChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint16_t getSharedKey() const;
    virtual void setSharedKey(uint16_t sharedKey);

    virtual uint16_t getHMacIdentifier() const;
    virtual void setHMacIdentifier(uint16_t hMacIdentifier);

    virtual bool getHMacOk() const;
    virtual void setHMacOk(bool hMacOk);

    virtual void setHMACArraySize(size_t size);
    virtual size_t getHMACArraySize() const;
    virtual uint32_t getHMAC(size_t k) const;
    virtual void setHMAC(size_t k, uint32_t HMAC);
    virtual void insertHMAC(size_t k, uint32_t HMAC);
    [[deprecated]] void insertHMAC(uint32_t HMAC) {appendHMAC(HMAC);}
    virtual void appendHMAC(uint32_t HMAC);
    virtual void eraseHMAC(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpAuthenticationChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpAuthenticationChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:302</tt> by opp_msgtool.
 * <pre>
 * class SctpAsconfChunk extends SctpChunk
 * {
 *     \@customize;
 *     uint32_t serialNumber;
 *     L3Address addressParam;
 *     uint32_t peerVTag; //for NAT
 *     abstract SctpParameter *asconfParams[];
 * }
 * </pre>
 *
 * SctpAsconfChunk_Base is only useful if it gets subclassed, and SctpAsconfChunk is derived from it.
 * The minimum code to be written for SctpAsconfChunk is the following:
 *
 * <pre>
 * class INET_API SctpAsconfChunk : public SctpAsconfChunk_Base
 * {
 *   private:
 *     void copy(const SctpAsconfChunk& other) { ... }

 *   public:
 *     SctpAsconfChunk(const char *name=nullptr) : SctpAsconfChunk_Base(name) {}
 *     SctpAsconfChunk(const SctpAsconfChunk& other) : SctpAsconfChunk_Base(other) {copy(other);}
 *     SctpAsconfChunk& operator=(const SctpAsconfChunk& other) {if (this==&other) return *this; SctpAsconfChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SctpAsconfChunk *dup() const override {return new SctpAsconfChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SctpAsconfChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SctpAsconfChunk)
 * </pre>
 */
class INET_API SctpAsconfChunk_Base : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t serialNumber = 0;
    ::inet::L3Address addressParam;
    uint32_t peerVTag = 0;

  private:
    void copy(const SctpAsconfChunk_Base& other);

  protected:
    bool operator==(const SctpAsconfChunk_Base&) = delete;
    // make constructors protected to avoid instantiation
    SctpAsconfChunk_Base(const char *name=nullptr);
    SctpAsconfChunk_Base(const SctpAsconfChunk_Base& other);
    // make assignment operator protected to force the user override it
    SctpAsconfChunk_Base& operator=(const SctpAsconfChunk_Base& other);

  public:
    virtual ~SctpAsconfChunk_Base();
    virtual SctpAsconfChunk_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SctpAsconfChunk");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getSerialNumber() const;
    virtual void setSerialNumber(uint32_t serialNumber);

    virtual const ::inet::L3Address& getAddressParam() const;
    virtual ::inet::L3Address& getAddressParamForUpdate() { return const_cast<::inet::L3Address&>(const_cast<SctpAsconfChunk_Base*>(this)->getAddressParam());}
    virtual void setAddressParam(const ::inet::L3Address& addressParam);

    virtual uint32_t getPeerVTag() const;
    virtual void setPeerVTag(uint32_t peerVTag);

    virtual void setAsconfParamsArraySize(size_t size) = 0;
    virtual size_t getAsconfParamsArraySize() const = 0;
    virtual const SctpParameter * getAsconfParams(size_t k) const = 0;
    virtual SctpParameter * getAsconfParamsForUpdate(size_t k) { return const_cast<SctpParameter *>(const_cast<SctpAsconfChunk_Base*>(this)->getAsconfParams(k));}
    virtual void setAsconfParams(size_t k, SctpParameter * asconfParams) = 0;
    virtual void insertAsconfParams(size_t k, SctpParameter * asconfParams) = 0;
    [[deprecated]] void insertAsconfParams(SctpParameter * asconfParams) {appendAsconfParams(asconfParams);}
    virtual void appendAsconfParams(SctpParameter * asconfParams) = 0;
    virtual void eraseAsconfParams(size_t k) = 0;
};

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:311</tt> by opp_msgtool.
 * <pre>
 * class SctpAsconfAckChunk extends SctpChunk
 * {
 *     \@customize;
 *     uint32_t serialNumber;
 *     abstract SctpParameter *asconfResponse[];
 * }
 * </pre>
 *
 * SctpAsconfAckChunk_Base is only useful if it gets subclassed, and SctpAsconfAckChunk is derived from it.
 * The minimum code to be written for SctpAsconfAckChunk is the following:
 *
 * <pre>
 * class INET_API SctpAsconfAckChunk : public SctpAsconfAckChunk_Base
 * {
 *   private:
 *     void copy(const SctpAsconfAckChunk& other) { ... }

 *   public:
 *     SctpAsconfAckChunk(const char *name=nullptr) : SctpAsconfAckChunk_Base(name) {}
 *     SctpAsconfAckChunk(const SctpAsconfAckChunk& other) : SctpAsconfAckChunk_Base(other) {copy(other);}
 *     SctpAsconfAckChunk& operator=(const SctpAsconfAckChunk& other) {if (this==&other) return *this; SctpAsconfAckChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SctpAsconfAckChunk *dup() const override {return new SctpAsconfAckChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SctpAsconfAckChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SctpAsconfAckChunk)
 * </pre>
 */
class INET_API SctpAsconfAckChunk_Base : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t serialNumber = 0;

  private:
    void copy(const SctpAsconfAckChunk_Base& other);

  protected:
    bool operator==(const SctpAsconfAckChunk_Base&) = delete;
    // make constructors protected to avoid instantiation
    SctpAsconfAckChunk_Base(const char *name=nullptr);
    SctpAsconfAckChunk_Base(const SctpAsconfAckChunk_Base& other);
    // make assignment operator protected to force the user override it
    SctpAsconfAckChunk_Base& operator=(const SctpAsconfAckChunk_Base& other);

  public:
    virtual ~SctpAsconfAckChunk_Base();
    virtual SctpAsconfAckChunk_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SctpAsconfAckChunk");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getSerialNumber() const;
    virtual void setSerialNumber(uint32_t serialNumber);

    virtual void setAsconfResponseArraySize(size_t size) = 0;
    virtual size_t getAsconfResponseArraySize() const = 0;
    virtual const SctpParameter * getAsconfResponse(size_t k) const = 0;
    virtual SctpParameter * getAsconfResponseForUpdate(size_t k) { return const_cast<SctpParameter *>(const_cast<SctpAsconfAckChunk_Base*>(this)->getAsconfResponse(k));}
    virtual void setAsconfResponse(size_t k, SctpParameter * asconfResponse) = 0;
    virtual void insertAsconfResponse(size_t k, SctpParameter * asconfResponse) = 0;
    [[deprecated]] void insertAsconfResponse(SctpParameter * asconfResponse) {appendAsconfResponse(asconfResponse);}
    virtual void appendAsconfResponse(SctpParameter * asconfResponse) = 0;
    virtual void eraseAsconfResponse(size_t k) = 0;
};

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:318</tt> by opp_msgtool.
 * <pre>
 * class SctpAddIPParameter extends SctpParameter
 * {
 *     uint32_t requestCorrelationId; //assigned by the sender to identify each request parameter
 *     L3Address addressParam;
 * }
 * </pre>
 */
class INET_API SctpAddIPParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t requestCorrelationId = 0;
    ::inet::L3Address addressParam;

  private:
    void copy(const SctpAddIPParameter& other);

  protected:
    bool operator==(const SctpAddIPParameter&) = delete;

  public:
    SctpAddIPParameter(const char *name=nullptr);
    SctpAddIPParameter(const SctpAddIPParameter& other);
    virtual ~SctpAddIPParameter();
    SctpAddIPParameter& operator=(const SctpAddIPParameter& other);
    virtual SctpAddIPParameter *dup() const override {return new SctpAddIPParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getRequestCorrelationId() const;
    virtual void setRequestCorrelationId(uint32_t requestCorrelationId);

    virtual const ::inet::L3Address& getAddressParam() const;
    virtual ::inet::L3Address& getAddressParamForUpdate() { return const_cast<::inet::L3Address&>(const_cast<SctpAddIPParameter*>(this)->getAddressParam());}
    virtual void setAddressParam(const ::inet::L3Address& addressParam);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpAddIPParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpAddIPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:324</tt> by opp_msgtool.
 * <pre>
 * class SctpDeleteIPParameter extends SctpParameter
 * {
 *     uint32_t requestCorrelationId; //assigned by the sender to identify each request parameter
 *     L3Address addressParam;
 * }
 * </pre>
 */
class INET_API SctpDeleteIPParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t requestCorrelationId = 0;
    ::inet::L3Address addressParam;

  private:
    void copy(const SctpDeleteIPParameter& other);

  protected:
    bool operator==(const SctpDeleteIPParameter&) = delete;

  public:
    SctpDeleteIPParameter(const char *name=nullptr);
    SctpDeleteIPParameter(const SctpDeleteIPParameter& other);
    virtual ~SctpDeleteIPParameter();
    SctpDeleteIPParameter& operator=(const SctpDeleteIPParameter& other);
    virtual SctpDeleteIPParameter *dup() const override {return new SctpDeleteIPParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getRequestCorrelationId() const;
    virtual void setRequestCorrelationId(uint32_t requestCorrelationId);

    virtual const ::inet::L3Address& getAddressParam() const;
    virtual ::inet::L3Address& getAddressParamForUpdate() { return const_cast<::inet::L3Address&>(const_cast<SctpDeleteIPParameter*>(this)->getAddressParam());}
    virtual void setAddressParam(const ::inet::L3Address& addressParam);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpDeleteIPParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpDeleteIPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:330</tt> by opp_msgtool.
 * <pre>
 * class SctpSetPrimaryIPParameter extends SctpParameter
 * {
 *     uint32_t requestCorrelationId; //assigned by the sender to identify each request parameter
 *     L3Address addressParam;
 * }
 * </pre>
 */
class INET_API SctpSetPrimaryIPParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t requestCorrelationId = 0;
    ::inet::L3Address addressParam;

  private:
    void copy(const SctpSetPrimaryIPParameter& other);

  protected:
    bool operator==(const SctpSetPrimaryIPParameter&) = delete;

  public:
    SctpSetPrimaryIPParameter(const char *name=nullptr);
    SctpSetPrimaryIPParameter(const SctpSetPrimaryIPParameter& other);
    virtual ~SctpSetPrimaryIPParameter();
    SctpSetPrimaryIPParameter& operator=(const SctpSetPrimaryIPParameter& other);
    virtual SctpSetPrimaryIPParameter *dup() const override {return new SctpSetPrimaryIPParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getRequestCorrelationId() const;
    virtual void setRequestCorrelationId(uint32_t requestCorrelationId);

    virtual const ::inet::L3Address& getAddressParam() const;
    virtual ::inet::L3Address& getAddressParamForUpdate() { return const_cast<::inet::L3Address&>(const_cast<SctpSetPrimaryIPParameter*>(this)->getAddressParam());}
    virtual void setAddressParam(const ::inet::L3Address& addressParam);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpSetPrimaryIPParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpSetPrimaryIPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:336</tt> by opp_msgtool.
 * <pre>
 * class SctpSupportedExtensionsParameter extends SctpParameter
 * {
 *     uint16_t sctpChunkTypes[];
 * }
 * </pre>
 */
class INET_API SctpSupportedExtensionsParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint16_t *sctpChunkTypes = nullptr;
    size_t sctpChunkTypes_arraysize = 0;

  private:
    void copy(const SctpSupportedExtensionsParameter& other);

  protected:
    bool operator==(const SctpSupportedExtensionsParameter&) = delete;

  public:
    SctpSupportedExtensionsParameter(const char *name=nullptr);
    SctpSupportedExtensionsParameter(const SctpSupportedExtensionsParameter& other);
    virtual ~SctpSupportedExtensionsParameter();
    SctpSupportedExtensionsParameter& operator=(const SctpSupportedExtensionsParameter& other);
    virtual SctpSupportedExtensionsParameter *dup() const override {return new SctpSupportedExtensionsParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setSctpChunkTypesArraySize(size_t size);
    virtual size_t getSctpChunkTypesArraySize() const;
    virtual uint16_t getSctpChunkTypes(size_t k) const;
    virtual void setSctpChunkTypes(size_t k, uint16_t sctpChunkTypes);
    virtual void insertSctpChunkTypes(size_t k, uint16_t sctpChunkTypes);
    [[deprecated]] void insertSctpChunkTypes(uint16_t sctpChunkTypes) {appendSctpChunkTypes(sctpChunkTypes);}
    virtual void appendSctpChunkTypes(uint16_t sctpChunkTypes);
    virtual void eraseSctpChunkTypes(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpSupportedExtensionsParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpSupportedExtensionsParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:341</tt> by opp_msgtool.
 * <pre>
 * class SctpErrorCauseParameter extends SctpParameter
 * {
 *     uint32_t responseCorrelationId;
 *     uint32_t errorCauseType;
 * }
 * </pre>
 */
class INET_API SctpErrorCauseParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t responseCorrelationId = 0;
    uint32_t errorCauseType = 0;

  private:
    void copy(const SctpErrorCauseParameter& other);

  protected:
    bool operator==(const SctpErrorCauseParameter&) = delete;

  public:
    SctpErrorCauseParameter(const char *name=nullptr);
    SctpErrorCauseParameter(const SctpErrorCauseParameter& other);
    virtual ~SctpErrorCauseParameter();
    SctpErrorCauseParameter& operator=(const SctpErrorCauseParameter& other);
    virtual SctpErrorCauseParameter *dup() const override {return new SctpErrorCauseParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getResponseCorrelationId() const;
    virtual void setResponseCorrelationId(uint32_t responseCorrelationId);

    virtual uint32_t getErrorCauseType() const;
    virtual void setErrorCauseType(uint32_t errorCauseType);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpErrorCauseParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpErrorCauseParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:347</tt> by opp_msgtool.
 * <pre>
 * class SctpSimpleErrorCauseParameter extends SctpParameter
 * {
 *     uint16_t value;
 * }
 * </pre>
 */
class INET_API SctpSimpleErrorCauseParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint16_t value = 0;

  private:
    void copy(const SctpSimpleErrorCauseParameter& other);

  protected:
    bool operator==(const SctpSimpleErrorCauseParameter&) = delete;

  public:
    SctpSimpleErrorCauseParameter(const char *name=nullptr);
    SctpSimpleErrorCauseParameter(const SctpSimpleErrorCauseParameter& other);
    virtual ~SctpSimpleErrorCauseParameter();
    SctpSimpleErrorCauseParameter& operator=(const SctpSimpleErrorCauseParameter& other);
    virtual SctpSimpleErrorCauseParameter *dup() const override {return new SctpSimpleErrorCauseParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint16_t getValue() const;
    virtual void setValue(uint16_t value);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpSimpleErrorCauseParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpSimpleErrorCauseParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:352</tt> by opp_msgtool.
 * <pre>
 * class SctpSuccessIndication extends SctpParameter
 * {
 *     uint32_t responseCorrelationId;
 * }
 * </pre>
 */
class INET_API SctpSuccessIndication : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t responseCorrelationId = 0;

  private:
    void copy(const SctpSuccessIndication& other);

  protected:
    bool operator==(const SctpSuccessIndication&) = delete;

  public:
    SctpSuccessIndication(const char *name=nullptr);
    SctpSuccessIndication(const SctpSuccessIndication& other);
    virtual ~SctpSuccessIndication();
    SctpSuccessIndication& operator=(const SctpSuccessIndication& other);
    virtual SctpSuccessIndication *dup() const override {return new SctpSuccessIndication(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getResponseCorrelationId() const;
    virtual void setResponseCorrelationId(uint32_t responseCorrelationId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpSuccessIndication& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpSuccessIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:357</tt> by opp_msgtool.
 * <pre>
 * class NatMessage extends cMessage
 * {
 *     bool multi;
 *     uint16_t peer1;
 *     L3Address peer1Addresses[];
 *     uint32_t portPeer1;
 *     uint16_t peer2;
 *     L3Address peer2Addresses[];
 *     uint32_t portPeer2;
 * }
 * </pre>
 */
class INET_API NatMessage : public ::omnetpp::cMessage
{
  protected:
    bool multi = false;
    uint16_t peer1 = 0;
    ::inet::L3Address *peer1Addresses = nullptr;
    size_t peer1Addresses_arraysize = 0;
    uint32_t portPeer1 = 0;
    uint16_t peer2 = 0;
    ::inet::L3Address *peer2Addresses = nullptr;
    size_t peer2Addresses_arraysize = 0;
    uint32_t portPeer2 = 0;

  private:
    void copy(const NatMessage& other);

  protected:
    bool operator==(const NatMessage&) = delete;

  public:
    NatMessage(const char *name=nullptr);
    NatMessage(const NatMessage& other);
    virtual ~NatMessage();
    NatMessage& operator=(const NatMessage& other);
    virtual NatMessage *dup() const override {return new NatMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getMulti() const;
    virtual void setMulti(bool multi);

    virtual uint16_t getPeer1() const;
    virtual void setPeer1(uint16_t peer1);

    virtual void setPeer1AddressesArraySize(size_t size);
    virtual size_t getPeer1AddressesArraySize() const;
    virtual const ::inet::L3Address& getPeer1Addresses(size_t k) const;
    virtual ::inet::L3Address& getPeer1AddressesForUpdate(size_t k) { return const_cast<::inet::L3Address&>(const_cast<NatMessage*>(this)->getPeer1Addresses(k));}
    virtual void setPeer1Addresses(size_t k, const ::inet::L3Address& peer1Addresses);
    virtual void insertPeer1Addresses(size_t k, const ::inet::L3Address& peer1Addresses);
    [[deprecated]] void insertPeer1Addresses(const ::inet::L3Address& peer1Addresses) {appendPeer1Addresses(peer1Addresses);}
    virtual void appendPeer1Addresses(const ::inet::L3Address& peer1Addresses);
    virtual void erasePeer1Addresses(size_t k);

    virtual uint32_t getPortPeer1() const;
    virtual void setPortPeer1(uint32_t portPeer1);

    virtual uint16_t getPeer2() const;
    virtual void setPeer2(uint16_t peer2);

    virtual void setPeer2AddressesArraySize(size_t size);
    virtual size_t getPeer2AddressesArraySize() const;
    virtual const ::inet::L3Address& getPeer2Addresses(size_t k) const;
    virtual ::inet::L3Address& getPeer2AddressesForUpdate(size_t k) { return const_cast<::inet::L3Address&>(const_cast<NatMessage*>(this)->getPeer2Addresses(k));}
    virtual void setPeer2Addresses(size_t k, const ::inet::L3Address& peer2Addresses);
    virtual void insertPeer2Addresses(size_t k, const ::inet::L3Address& peer2Addresses);
    [[deprecated]] void insertPeer2Addresses(const ::inet::L3Address& peer2Addresses) {appendPeer2Addresses(peer2Addresses);}
    virtual void appendPeer2Addresses(const ::inet::L3Address& peer2Addresses);
    virtual void erasePeer2Addresses(size_t k);

    virtual uint32_t getPortPeer2() const;
    virtual void setPortPeer2(uint32_t portPeer2);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NatMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NatMessage& obj) {obj.parsimUnpack(b);}


}  // namespace sctp
}  // namespace inet


namespace omnetpp {

template<> inline inet::sctp::SctpHeader_Base *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpHeader_Base*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpInitChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpInitChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpInitAckChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpInitAckChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpCookieEchoChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpCookieEchoChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpCookie *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpCookie*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpCookieAckChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpCookieAckChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpDataMsg *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpDataMsg*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpDataChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpDataChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpForwardTsnChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpForwardTsnChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpSackChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpSackChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpAbortChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpAbortChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpHeartbeatChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpHeartbeatChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpHeartbeatAckChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpHeartbeatAckChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpShutdownChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpShutdownChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpShutdownAckChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpShutdownAckChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpShutdownCompleteChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpShutdownCompleteChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpErrorChunk_Base *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpErrorChunk_Base*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpParameter *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpParameter*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpPacketDropChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpPacketDropChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpStreamResetChunk_Base *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpStreamResetChunk_Base*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpOutgoingSsnResetRequestParameter *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpOutgoingSsnResetRequestParameter*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpIncomingSsnResetRequestParameter_Base *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpIncomingSsnResetRequestParameter_Base*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpSsnTsnResetRequestParameter *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpSsnTsnResetRequestParameter*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpStreamResetResponseParameter *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpStreamResetResponseParameter*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpAddStreamsRequestParameter *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpAddStreamsRequestParameter*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpResetTimer *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpResetTimer*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpAuthenticationChunk *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpAuthenticationChunk*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpAsconfChunk_Base *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpAsconfChunk_Base*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpAsconfAckChunk_Base *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpAsconfAckChunk_Base*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpAddIPParameter *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpAddIPParameter*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpDeleteIPParameter *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpDeleteIPParameter*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpSetPrimaryIPParameter *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpSetPrimaryIPParameter*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpSupportedExtensionsParameter *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpSupportedExtensionsParameter*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpErrorCauseParameter *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpErrorCauseParameter*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpSimpleErrorCauseParameter *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpSimpleErrorCauseParameter*>(ptr.get<cObject>()); }
template<> inline inet::sctp::SctpSuccessIndication *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::SctpSuccessIndication*>(ptr.get<cObject>()); }
template<> inline inet::sctp::NatMessage *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::sctp::NatMessage*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __INET__SCTP_SCTPHEADER_M_H

