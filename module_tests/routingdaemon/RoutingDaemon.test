%description:
RoutingDaemon initialize function test

%file: package.ned
package RoutingDaemon;
@namespace(RoutingDaemon);

%file: test.ned
package RoutingDaemon;

import ned.DatarateChannel;
import modules.QRSA.RoutingDaemon.*;
import modules.QNode;


channel MockChannel extends DatarateChannel {
    parameters:
        double distance @unit(km) = default(20km);
        double speed_of_light_in_fiber @unit(km) = default(208189.206944km);
}
simple TestRoutingDaemon extends RoutingDaemon {
    parameters:
    @class(TestRoutingDaemon);
    gates:
        inout quantum_port;
}
module MockQRSA {

    parameters:
        bool is_initiator = false;
    gates:
        inout quantum_port @loose;

    submodules:
        rd: TestRoutingDaemon;

    connections:
        quantum_port <--> rd.quantum_port;
}

simple MockStationaryQubit {
    parameters:
        double emission_success_probability = default(1);
    gates:
        inout quantum_port;
}
simple ModTypeInitializer{}
module MockQNIC {
    parameters:
        int self_qnic_address;
        int self_qnic_type;
    gates:
        inout quantum_port;
    submodules:
        statQubit[1] : MockStationaryQubit;
    connections:
        quantum_port <--> statQubit[0].quantum_port;
}

module MockQNode {

    parameters:
        string address;
        string node_type;
        bool is_initiator;
        int mass;
        string included_in_topology = "yes";
    gates:
        inout quantum_port[] @loose;

    submodules:
        init: ModTypeInitializer;
        qrsa: MockQRSA;
        qnic[1]: MockQNIC {
            parameters:
                self_qnic_address = 0;
                self_qnic_type = 0;
        }

    connections:
        quantum_port[0] <--> qnic[0].quantum_port;
}

network RoutingDaemonTestNet
{
    submodules:
        mockQNode1: MockQNode {
            address = "0.1";
            node_type = "EndNode";
            is_initiator = false;
            mass = 100;
        }
        mockQNode2: MockQNode {
            address = "0.2";
            node_type = "EndNode";
            is_initiator = false;
            mass = 100;
        }
    connections:
        mockQNode1.quantum_port++ <--> MockChannel {  distance = 10km; } <--> mockQNode2.quantum_port++;
}

%inifile: omnetpp.ini

[General]
network = RoutingDaemonTestNet
**.emission_success_probability = 1

%file: test_routingdaemon.cc
#include <omnetpp.h>
#include <messages/classical_messages.h>
#include <modules/QRSA/RoutingDaemon/RoutingDaemon.h>
#include <modules/Common/Queue.h>
#include <test_utils/TestUtils.h>
using namespace omnetpp;
using namespace quisp::messages;
namespace RoutingDaemon {

class TestRoutingDaemon : public quisp::modules::routing_daemon::RoutingDaemon {
 public:
  TestRoutingDaemon() : RoutingDaemon() {}
  void finish() override {
    QNodeAddr other_node_addr{3 - myAddress.host_addr};
    if (qrtable[other_node_addr] != 0)
      printf("FAIL: in the routing table, the value is %d but the expected value is %d\n", qrtable[other_node_addr], myAddress);
  }
};
Define_Module(TestRoutingDaemon);

class MockStationaryQubit : public cSimpleModule {};
Define_Module(MockStationaryQubit);

class ModTypeInitializer: public omnetpp::cSimpleModule {
    void initialize() override {
        getParentModule()->setComponentType( cModuleType::get("modules.QNode"));
    }
};
Define_Module(ModTypeInitializer);

}; //namespace

%not-contains: test.out
FAIL
